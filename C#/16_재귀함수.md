# 재귀함수(recursive function)

- 이미 해결한 작은 문제에 업혀 더 큰 문제를 해결하는 방법
- 예: 1에서 5까지의 합을 구하려는데
  - 이미 1~4까지 더한 결과가 10임을 알고 있음
  - 그러면 여기에 5만 더하면 15가 됨
- 프로그래밍에서는 함수A가 매개변수만 바꾸어 다시 함수A를 호출하는 방법으로 구현

```c
// 재귀함수의 예
static uint SumRecursive(uint num)
{
    if (num == 0)
    {
        return 0; // 종료조건
    }
    else
    {
        return num + SumRecursive(num - 1); // 재귀호출
    }
}

static void Main(string[] args)
{
    Console.WriteLine(SumRecursive(3));
}
```

`SumRecursive(3);`  
= return 3 + SumRecursive(2);
= return 3 + (2 + SumRecursive(1));
= return 3 + (2 + (1 + SumRecursive(0)));
= return 3 + (2 + (1 + 0));
= return 6;

## 재귀 함수의 구성요소

- 종료조건(ending condition, base case)
  - 가장 기본이 되는 문제set
  - 더 이상 재귀 함수를 호출하지 않고 값을 반환하는 조건
  - 매우 간단히 함수의 반환 값을 찾을 수 있는 경우
  - 이것이 없으면 함수를 무한히 재귀적으로 호출
    - 재귀문이 끝나지 않아서 문제 발생
- 재귀적 함수 호출
  - 종료조건이 아닌 경우
  - 함수의 인자를 바꿔 스스로를 다시 호출
  - 이때, 함수의 인자는 현재 문제보다 작은 문제를 대표해야 함
  - 즉, 동일한 동작을 보다 작은 문제에 적용
  - 재귀함수 작성할 때 기본적으로 종료조건을 생각하는게 좋음

## 반복문과의 비교

- 매우 단순한 문제는 당연히 반복문이 쉬움
  - 사실 모든 재귀 함수는 반복문으로 해결 가능
- 그러나 복잡한 문제일수록 재귀 함수가 더 편함
  - 이진 검색
  - 트리 구조
  - 퀵 정렬
  - 하노이의 탑
  - 어떤 폴더 아래에 있는 모든 파일 목록 구하기

## 피보나치 수열로 이해하는 재귀 함수

- 제 0항은 0, 제 1항은 1이며, 그 뒤의 모든 항은 바로 앞 두항의 합인 수열
  `0 1 1 2 3 5 8 13 21 34 55 ...`
- 수학적 정의
  F<sub>0</sub> = 0,  
  F<sub>1</sub> = 1,
  F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub> , (n > 1)

```c
public static int FibonacciRecursive(uint number)
{
    if (number == 0)
    {
        return 0; // 종료 조건
    }
    if (number == 1)
    {
        return 1; // 종료 조건
    }

    return FibonacciRecursive(number - 2) + FibonacciRecursive(number - 1);
}

// 피보나치 함수 호출
static void Main(string[] args)
{
    FibonacciRecursive(10);
}
```

- 함수는 신뢰의 문제
- 재귀 함수는 더 큰 신뢰를 요구
- Fibonacci(4)를 구하려 할 떄
  - Fibonacci(2), Fibonacci(3)은 반드시 올바른 값을 반환한다 믿어야 함
  - 종료조건:Fibonacci(0)은 0, Fibonacci(1)은 1을 반드시 반환
  - 그 후의 수는 위 종료 조건에 기초하여 값을 계산할 수 있음

## 폴더의 목록을 가져오는 함수(의사코드)

```c
// GetDirectoryNames(path): path 안에 있는 모든 폴더의 이름을 가져오는 함수
// GetFileNames(path): path 안에 있는 모든 파일의 이름을 가져오는 함수

static string[] GetFileNamesRecursive(string path)
{
    string[] fileNames;
    string[] directoryNames = GetDirectoryNames(path);
    for (int i = 0; i < directoryNames.Length; ++i)
    {
        filesNames += GetFileNamesRecursive(directoryNames[i]);
    }
    filesNames += GetFileNames(path);
    return filesNames;
}
```

## 재귀적 해결법 = 논리력

- 프로그래머의 논리력을 평가하기에 적합
- 매우 큰 문제를 작게 쪼개서 증명할 수 있나
  - 절대 틀릴 수 없는 최소한의 문제를 품
  - 최소한 문제의 해법에 의존하여 그 보다 하나 더 큰 문제를 해결
  - 그 과정을 반복하면 논리적으로 최종 문제까지 해결
- 수학적 귀납법과 매우 밀접

### 수학적 귀납법 예시

`모든 자연수 n에 대하여 '0 + 1 + 2 + ... + n = n(n+1)/2' 이 항상 성립하는지 증명하시오.`

1. n이 0일 때, 위의 식이 성립하는지 본다.
  `0 = 0(0+1)/2`
  0 맞음(재귀함수의 종료조건과 비슷)
2. 자연수 0부터 k까지의 합이 `k(k+1)/2`으로 성립한다고 가정한다.
  (일단 맞다고 가정)
3. 그 다음 자연수인 (k+1)까지의 합도 이 공식을 만족하는지 증명한다.
  `(0+1+2+...+k)+(k+1)=(k+1)((k+1)+1)/2`  
  = `k(k+1)/2 + (k+1) = (k(k+1) + 2(k+1))/2`
4. `k(k+1)/2`이 항상 성립한다는 가정하에 `k+1`도 성립한다는 것이 확인
5. 최소자연수 0을 대입했을 때 식이 성립하는 것이 확인 되었으므로 0 다음 자연수인 1도 성립하고 그다음 자연수 2도 성립하고...n도 성립하고  
n+1까지도 성립한다는것이 증명된다.

## 하노이의 탑으로 이해하는 재귀 함수

A위치에 있는 모든 원판을 C의 위치로 옮기기

![   하노이의  탑  그림   ](http://koistudy.net/bbs/prob/157/157_1.jpg)

브라흐마의 규칙

1. 한 번에 원판 하나씩만 옮길 수 있음
2. 작은 원판 위에 그 보다 큰 원판을 옮길 수 없음

### 하노이의 탑 - 풀이

1. 막대 세 개가 있고, 한 막대에 n개의 원판이 있음

    - n개의 원판의 상위 n-1개를 다른 막대에 옮길 수 있다고 가정
      - n-1개의 원판을 중간 막대로 옮김
      - 마지막 n 번째 원판은  목적지 막대에 옮김
      - 중간 막대에 있던 n-1개의 원판을 목적지 막대에 옮김
2. 막대 세 개가 있고, 한 막대에 n-1개의 원판이 있음

    - n-1개의 원판에서 상위 n-2개를 다른 막대에 옮길 수 있다고 가정
      - n-2의 원판을 중간 막대기로 옮김
      - 마지막 n-1번째 원판을 목적지 막대에 옮김
    - 이렇게.. n-3개, n-4개... n-(n-2)개까지 감
    - n-(n-2) = n-n+2 = 2개
3. 막대 세개가 있고, 한 막대에 2개의 원판이 있음

    - 2개의 원판에서 상위 1개를 다른 막대에 옮길 수 있다고 가정
      - 1개의 원판을 중간 막대에 옮김
      - 마지막 2번째 원판을 목적지 막대에 옮김
      - 중간 막대에 있던 1개의 원판을 목적지 막대에 옮김
4. 막대 세개가 있고, 한 막대에 1개의 원판이 있음

    - 1개의 원판을 다른 막대에 옮길 수 있음(한개니까) -> 종료조건(참o)
    - 원판 1개 목적지 막대로 옮기는 것이 참o  
    -> 2개도 참o  
    -> 종료조건이 참이므로 위의 모든 조건들 모두 참o

## 재귀 함수의 장점

- 개념적으로 매우 훌륭함
- 증명이 가능하기에 두 발 뻗고 잘 수 있다.

### 단점

- 효율성이 떨어진다.
  - 반면에 반복문은 그런 문제가x
  - 이전 연산의 결과를 캐싱하기 때문
- 스택 오버플로우
  - 함수 호출 깊이에는 제한이 있음

## 베스트 프랙티스

- 캐싱 없이 간단한 반복문으로 작성 가능한 문제는 반복문으로
  - 예: 1~n까지 수의 합 구하기
- 그 외에는 재귀 함수로 우선 작성
  - 설계 및 이해가 용이하기 때문
- 다음의 경우에는 반복문으로 코드 리팩토링(code refactoring_코드의 구조 재조정)
  - 함수 호출의 최대 깊이를 확정할 수 없음
  - 또는, 성능상의 문제를 발견
  
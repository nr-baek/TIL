# 기본 자료형(Primitive Types)

_컴퓨터가 이해할 수 있는 가장 자연스러운 형태의 데이터_

- 전부다 숫자임
- 디지털은 0과 1
- 컴퓨터는 디지털
    - 0과 1로만 사용해서 표현을 해야함(0과 1을 사용하는 2진수)

#### [자료의 크기]

- 최소 단위는 비트(bit)
    - 1 혹은 0을 담을 수 있음(한개만)
    - [0] -> 0을 담고 있는 비트
    - [1] -> 1을 담고 있는 비트
- 8비트가 모이면 바이트(byte)
    - 각 비트는 마찬가지로 하나의 1 혹은 0을 담을 수 있음
    - [][][][][][][][] 비트가 8개
- 1024바이트 = 1 킬로 바이트(KB)
- 1024킬로바이트 = 1 메가 바이트(MB)

## 1. 정수형(Integer Types)

비트수에 따라 수의 크기가 결정 됨

- 0, 1, 2, 3과 같은 정수를 담을 수 있는 자료형
- byte, short, int, long
- 프로그래밍 언어마다 담을 수 있는 자료의 크기 차이는 존재

|자료형 이름|자료형 크기|
|------|-----|
|byte|8비트|
|short|16비트|
|int|32비트|
|long|64비트|

- byte의 경우 2의 8승 = 256개의 숫자를 표현 가능
- short의 경우 2의 16승 = 65,536개의 숫자를 표현 가능
- int의 경우 2의 32승 = 4,294,967,296개의 숫자를 표현 가능
- long의 경우 2의 64승 = 18,446,744,073,709,551,616개의 숫자를 표현 가능

## 2. 부동소수점형(Floating-Point Types)

- 3.14, 0.9와 같은 실수를 담을 수 있는 자료형
- float, double
- 프로그래밍 언어마다 담을 수 있는 자료의 크기 차이는 존재

|자료형 이름|자료형 크기|
|------|-----|
|float|32비트|
|double|64비트|

## 3. 문자형(Character Type)

- 하나의 '문자'를 담는 자료형
    - 알파벳, 숫자, 특수문자(!,@,* 등등)
    - 문자를 감쌀 때 작은 따옴표(')를 사용
    `'a', '1', '-'`
- char(16비트)
- C#이 char를 조금 특이하게 다룸
    - 이유는 C#에서는 char가 유니코드이기 때문
    - C/C++에서는 ASCII코드(8비트)
- 사람들끼리 각 문자들을 숫자랑 1:1 매칭하기로 약속


## 4. 불리언형(Boolean Type)

- 참(true)과 거짓(false)을 표현하는 자료형
- bool
- C++과 같은 일부 언어에서는 false를 0으로 true를 0이 아닌 값으로 변환이 가능(C#에서는 불가능)

### < C#에서의 기본 자료형 >

|자료형 이름|자료형 크기|
|------|-----|
|byte|8비트|
|short|16비트|
|int|32비트|
|long|64비트|
|float|32비트|
|double|64비트|

_필요에 따라 맞는 자료형을 선택해서 쓸 때가 있지만 기본적인 default로는 int(32비트)와 float(32비트)를 사용한다._

----------------------

## 부호있는 자료형/ 부호 없는 자료형

음수 표현 방법 -> 같은 자료형을 두 종류로 나눔

### 1. 부호 있는 자료형

- 음수와 양수를 모두 표현

|자료형|자료형 범위|
|------|-----|
|sbyte|-128 ~ 127|
|short|-32,768 ~ 32,767|
|int|-2,147,483,648 ~ 2,147,483,647|
|long|-9,223,327,036,854,775,808 ~9,223,372,036,854,775,807|

### 2. 부호 없는 자료형

- 양수만 표현
- 보통 부호 있는 자료형 이름 앞에 'u'를 붙임

|자료형|자료형 범위|
|------|-----|
|byte|0~255|
|ushort|0~65,535|
|uint|0~4,294,967,295|
|ulong|0~18,446,744,073,709,551,615|

**부호 있는 변수와 없는 변수는 굉장히 중요**
- 프로그래머의 명백한 의도를 보여주기 때문

    ex) `int age = 17;`  

    - 변수 이름은 "나이"를 의미
    - 변수형은 int형으로 부호 있는 자료형
        - 그런데 나이는 항상 양수일텐데 나이에 음수가 들어온다면..?
    - **u**int age = 17;로 바꿔서 음수가 들어올 수 없도록 명백히 한다.

### 오버플로우(overflow)

- 연산의 결과로 자료형의 범위보다 큰 수가 나오는 경우를 말함
- 자료형의 크기는 변하지 않기 때문에 넘어가버린 비트는 버림
- 오버플로우가 발생할 경우 원치 않는 값이 나올 수 있음

### 변수의 자료형을 선택할 때 주의할 점

- 변수의 역할에 알맞은 자료형을 선택할 것
- 오버플로우를 고려해서 자료형을 선택할 것

------------------

## 상수의 접두사(prefix)와 접미사(postfix)

```

int intNum = 10   //10
int binaryNum = 0b10;   //2
int hexNum = 0x10;   //16
uint uIntNum = 10u;   //10
float floatNum = 10.0f;   //10
double doubleNum = 10.0;   //10
string stringNum = "10";   //10
```

- 접두사와 접미사는 상수의 앞이나 뒤에 상수를 꾸미는 기호

### 1. 상수 접두사

- 상수 앞에 붙는 기호로 진법을 나타냄
    - 2진수
        - **0b~**
        `int num1 = 0b10; -> 10진수로 2`
    - 16진수
        - **0x~**
        `int num2 = 0x10; -> 10진수로 16`

### 2. 상수 접미사

- 상수 뒤에 붙는 기호로 상수의 형을 나타냄
- **부호여부**(unsigned type)
    - **~u**
    - `int num1 = 10;`
    - `uint num2 = 10u;` unsigned형
    - `uint num3 = 0x10u;` unsigned형
- **long**(int의 두배 long형)
    - **~ㅣ**
    - `int num1 = 1l;` // 컴파일 오류
    - `long num2 = 10l;`
    - `long num3 = 10lu;` // 컴파일 오류
    - `ulong num4 = 10lu;`
- **float**
    - **~f**
    - `float num1 = 10.0f;`
    - `float num2 = 10.0;` // 컴파일 오류
- **double**
    - **없음 혹은 ~d**
    - `double num1 = 10.0;`
    - `double num2 = 10.0d;` 
    - 거의 'd'안붙이고 그냥 씀


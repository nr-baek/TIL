# C언어의 기본 문법

## C는 절차적 언어

- C는 순수하게 절차적 언어로만 사용 가능
- 즉, C로 작성한 코드는 데이터보다 프로세스에 중점이 맞춰져 있음
- 이게 반드시 나쁜 것은 아님
  - OOP언어에서도 종종 절차적 언어 스타일로 코드를 작성
- 또한, 절차적 언어는 이해하기 쉬움
  - 그냥 메뉴얼에 적힌 내용을 순서대로 따라하는 느낌
- 클래스(class) 없음
- 함수
  - 모두 전역(global) 함수
  - 기본적으로 어디에서나 호출 가능
- 변수
  - 함수 밖에 선언 되어있으면, 전역 변수
  - 함수 안에 선언 되어있으면, 지역(local) 변수

## 자료형

- 메모리를 사용하는 단위같은 것
- 기본 자료형(primitive types)
  - char
  - short
  - int
  - long
  - float
  - double
  - long double

### unsigned 와 singed

- C는 unsigned라는 단어를 자료형 이름 앞에 넣어줘야 함  
  - ex: unsigned char, unsigned int
- '부호 있음'을 명확하게 보여주기 위해서 signed를 붙일 수도 있음
  - ex: signed char, signed int
- unsigned/signed를 생략하면 '부호 있음'이 기본
  - 예외: char

### char

```c
char ch_a = 'a';
char ch_b = ch_a + 1; /* b */
char ch_C = 99;       /* c */
```

- **최소** 8비트인 정수형
- 표준은 8비트 이상이라고만 정의함
  - 어떤 컴파일러를 사용하느냐에 따라 char의 크기가 다름
  - <limits.h>헤더를 인클루드 한 뒤, CHAR_BIT를 보면 몇 비트인지 알 수 있음
- 참고로 C표준은 기본 자료형의 정확한 바이트 수를 강요 안 함
- 더 나아가 1바이트를 CHAR_BIT만큼이라고 말함
- 소형기기에 따라 특정 크기를 사용하는게 어려울 수 있기 때문

#### char와 ASCII문자

- 정수형
- char는 ASCII문자를 표현하기에 충분
  - 아스키는 0~127인 숫자
- 당연히 덧셈 가능

#### char와 signed/unsigned

- char도 정수형이니 signed(부호있음)와 unsigned(부호없음)가 있음
- signed/unsigned를 생략하면?
  - c표준은 정하지 않았음
  - 컴파일러에 따라 다름
- char의 기본 부호가 지정 안 된 이유
  - 아스키의 범위는 0~127이므로 부호 여부는 상관이 없음
- 단, 8비트 정수형으로 쓰려고 할 때는  
반드시 char앞에 signed/unsigned를 넣어주는게 좋음

  ```c
  signed char signed_char = -1;
  unsigned char unsigned_char = 255;
  ```

- 안그러면 포팅해도 문제없는 정수 범위는 0~127 사이 뿐

#### char로 표현 가능한 숫자의 범위(보통)

- 실제 보통(데스크톱 개발할 때) 안전하게 생각해도 되는 것
  1. 크기: 8비트
  2. 부호(unsigned/signed)를 생략할 경우: signed
    `char signed_char = -1;`
  3. 범위
  - 부호 없는 경우(unsigned): 0~255
  - 부호 있는 경우(signed): -128~127
    - (표준상)안전한 포팅을 위해서는 -128이 아니라 -127

### short

```c
short num = -30000; /* 기본: signed */
unsigned short unsigned_short = 65535;
signed short signed_short = -32767;
```

- **최소** 16비트이고 char의 크기 이상인 정수형
- 포팅 문제 없는 값의 범위
  - 부호 없는 short(unsigned short): 0 ~ 65535
  - 부호 있는 short(signed short): -32767 ~ 32767
- 기본 정수형(보통 int) 보다 짧음
- 즉, 메모리를 적게 쓰기 위해 사용
- 그러나 int대신 short를 사용할 경우 성능이 느려질 수도
  - 실제 cpu계산할 때는 int가 기본 크기인 경우가 많음
- 표준에 상관없이 보통 안전하게 생각해도 되는 것
  1. 크기: 16비트
  2. 범위
  - 부호 없는 경우(unsigned): 0~65535
  - 부호 있는 경우(signed): -32768~32767

### int

```c
int num = -32767; /* 기본: signed */
unsigned int unsigned_int = 65535;
signed int singed_int = -32767;
```

- 표준에 따르면 **최소**16비트 그리고 short크기 이상인 정수형

#### int는 기본 정수

- int는 그냥 '정수(integer)'라는 의미
- 따라서, CPU에게 앞뒤 생략하고 '정수 처리해!'라고 하면 CPU가 딱 아는 크기여야 함
- 그게 무엇의 크기일까?
  - CPU의 산술논리장치(ALU)가 사용하는 기본 데이터
  - 이 데이터를 워드라 하고, 그 크기를 워드 크기라고 함
  - 워드 크기는 레지스터 크기랑 일치
- 즉, CPU따라 다름
- 예전에는 16비트 CPU가 흔했음 -> 그래서 최소 16비트

#### int와 64비트 플랫폼

- 그 뒤에 32비트 컴퓨터가 나오면서 int의 크기는 32비트가 됨
- 그러나 지금은 64비트 컴퓨터? 그래도 32비트로 머묾
  - 원칙적으로 말하면 C표준을 어긴 것
  - 그러나 64비트로 올리면 32비트 정수를 어떻게 표현하지?..
  - 너무 오랫동안 32비트를 int의 크기로 사용
  - 32비트에서 64비트로 바꾼다고 성능이 무조건 빨라지지도 않음  
  (이유: 캐시 메모리 등)
  - 'int'를 64비트로 올리면 short는

#### int로 표현 가능한 숫자의 범위

- 포팅에 안전한 범위: short와 같음
- 표준에 상관없이 보통 안전하게 생각해도 되는 것
  1. 크기: 32비트
  2. 범위
  - 부호 없는 경우(unsigned): 0~4,294,967,295
  - 부호 있는 경우(signed): -2,147,483,648 ~ -2,147,483,647

#### int의 리터럴

```c
int signed_int = -1024;
unsigned int unsigned_int1 = 394;
unsigned int unsigned_int2 = 2147483648; /* 경고 */
unsigned int unsigned_int3 = 2147483648u; /* 경고 없음, 대문자 U도 됨 */
```

- 리터럴(ligeral)
  - 'u' 혹은 'U': 부호 없는(unsigned)수를 표현하는 접미사
    - 부호 있는 수의 최댓값보다 큰 값을 unsigned int에 대입할 경우 'u' 혹은 'U'를 붙여야 함
    - 안 붙이면 경고 발생

### long

```c
long num = -2147483648; /* 기본: signed */
unsigned long unsigned_long = 2147483647;
singed long singed_long = -2147483648;
```

- int가 16비트일 때 그것보다 2배 큰 자료형이 필요했음
- 따라서, long은 최소 32비트이고 int이상의 크기
  - 다른 언어에서는 long이 보통 64비트
- 포팅 안전한 범위: -2147483647 ~ 2147483647
- 표준에 상관없이 보통 안전하게 생각해도 되는 것
  - int와 같음

#### long의 리터럴

```c
long singed_long = -200000000l;    /* 대문자 L도 됨*/
unsigned long unsigned_long1 = 2147483647;
unsinged long unsigned_long2 = 2147483648; /* 경고 */
unsigned long unsigned_long3 = 2147483648ul; /* 경고 없음 */
```

- 리터럴
  - 'l'혹은'L': long을 의미하는 접미사
  - 'u'혹은'U': 부호 없는(unsigne) 수를 표현하는 접미사
  - 두 접미사를 같이 쓸 수 있음

### float

```c
float num = 3.14f;                     /* 컴파일 */
unsigned float unsigned_float = 3.14f; /* 컴파일 오류 */
signed float signed_float = -3.14f;    /* 컴파일 오류 */
```

- 표준에 따르면 C의 float은
  - IEEE 754일 수도 아닐 수도 있음
  - 컴파일러 구현에 따라 다름(최소한 C89에서는)
  - 크기는 char 이상이기만 하면 됨(8비트 이상)
- unsigned 형 없음
- 표준에 상관없이 보통 안전하게 생각해도 되는 것
  - 크기: 32비트
  - 범위: IEEE 754 Single과 동일
- 관련 헤더 파일: float.h

#### float의 리터럴

```c
float pi1 = 3.14f;  /* F도 됨 */
float pi2 = 3.14uf; /* 컴파일 오류, float은 접미사 u를 안씀 */
```

- 리터럴
  - 'f'혹은'F': float을 의미하는 접미사

### double

```c
double num = 3.14;    /* 컴파일 */
unsigned double unsigned_double = 3.14; /* 컴파일 오류 */
signed double signed_double = -3.14;  /* 컴파일 오류 */
```

- 표준에 따르면 CPU가 계산에 사용하는 기본 데이터 크기
  - 크기는 float 이상이면 됨
  - float은 그저 double보다 빠르게 연산하기 위해 만든 작은 부동소수점
- 역시 컴파일러 구현따라 다름
  - 즉, IEEE 754 Double이란 보장이 없음
- unsigned 형 없음
- 표준에 상관없이 보통 안전하게 생각해도 되는 것
  - 크기: 64비트
  - 범위: IEEE 754 Double과 동일
- 관련 헤더 파일: float.h

### long double

```c
long double num = 3.14;  /* 컴파일 */
unsigned long double unsigned_long_double = 3.14;  /* 컴파일 오류 */
signed long double singed_long_double = -3.14;  /* 컴파일 오류 */
```

- double보다 정밀도가 높음
- double이상의 크기면 됨
- 다른 부동소수점들과 마찬가지로 unsigend형 없음
- 관련 헤더 파일: float.h

## bool형

- C89에 없음
- C99에서 새로 들어옴

### bool형을 안쓰는 이유

- 정수로 대신 쓸 수 있음
- 0이면 false, 0이 아니면 true
- 하드웨어에서도 실제 bool이 없음
  - 0이냐 아니냐만 있음(모든게 숫자)
- 따라서, while문의 조건으로 숫자를 사용 가능함

### 코딩표준: 참, 거짓을 반환해야 할 때는

- C에서 참이나 거짓을 반환해야 하는 함수의 경우 보통 이렇게 함
  - 거짓일 때는 0을 반환
  - 참일 때는 1을 반환

```c
int is_student(const int id)
{
  if(/*조건*/) {
    return 1;
  }

  return 0;
}
```


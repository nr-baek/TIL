# C언어의 기본 문법2

## 함수

- C의 함수 선언은 C#과 거의 동일
- 다만 C는 접근 제어자(예: public, private 등)가 없음
- C의 함수는 기본적으로 모두 전역(global) 함수
- 즉, C의 함수는 어디서든 호출할 수 있음!
- 물론 그걸 제한할 수 있는 키워드가 있음

### 함수 오버로딩

- C에는 함수 오버로딩 없음
- 따라서 함수 명을 다르게 만들어야 함

### 함수 정의의 문제

```c
#include <stdio.h>

int main(void)
{
    foo();
    getchar();
    return 0;
}

void foo(void) /* 컴파일 오류 */
{
    printf("foo called");
}
```

- C는 언제나 위에서 아래로 코드를 훑음
- C89에서 함수 정의가 등장하기 전에 그 함수를 호출하면 컴파일러가 다음과 같이 가정
  - 반환형은 int
  - 그 매개변수는 아무거나 올 수 있음
- 따라서, 나중에 컴파일러가 int가 아닌 다른 것을 반환하는 함수를 찾으면 컴파일 오류를 뱉음
- 함수 호출 전에 함수의 정의를 위치시키면 컴파일 됨
  - 그러나 함수를 만들 때마다 그걸 호출하는 코드 위에 다 위치시켜야하고...100개의 함수면 그 순서에 따라 옮겨야하는 상황이 발생
  - C는 고대언어이기 때문
  - 이럴때는 **함수 선언**을 이용하면 됨.

### 함수 선언

- 함수의 구현체 없이 함수 원형(prototype)만 선언해 주는 것
- 함수 원형은 다음의 사항들을 명시
  1. 함수의 이름
  2. 반환형
  3. 매개변수들의 자료형
- 비교: 함수 정의(definition)는 실제로 함수를 구현해 놓은 것
  - 함수 정의는 그 자체로 함수 선언이기도 함(선언을 내포)

#### 함수 선언과 정의를 분리

```c
void foo(void); /* 함수 선언(전방 선언) */

int main(void)
{
    foo();
    getchar();
    return 0;
}

void foo(void) /* 함수 정의 */
{
    printf("foo called");
}
```

#### 함수 선언과 정의가 하나

```c
#include <stdio.h>

void foo(void) /* 함수 정의(+선언) */
{
    printf("foo called");
}

int main(void)
{
    foo();
    getchar();
    return 0;
}
```

#### 함수 선언의 위치

- 함수를 사용하기 전에 그 함수를 선언
  - 보통 파일의 제일 위에(전방 선언)
  - 혹은, 헤더 파일에(조금 더 좋은 방법)

#### 코딩표준: 함수선언

- 함수가 int를 반환한다 해도 함수선언을 해주자!
- C89/C90에서는 안해도 되긴 함..
- 그러나 C99 표준부터는 int 가정을 하지 않음
  - 어떤 컴파일러는 경고만 주고, 컴파일은 허용할 수도 있음
  - 모든 컴파일러가 그렇다는 보장이 없으므로 반드시 선언할 것

### 함수 매개변수의 평가 순서

- 표준에 따르면, 함수 매개변수의 평가 순서는 명시되어있지 않음(unspecified)
- 즉, 컴파일러에 따라 평가 순서가 달라질 수 있음
  `printf("%d, %d\n", add(num1, num2), subtract(num1, num2));` 의 함수에서  
  add와 subtract 둘 중 어느 매개변수가 먼저 호출될지는 **컴파일러 마음**
- 어느 쪽이 먼저 호출돼도 모두 올바른 동작
- 함수 매개변수의 평가 순서가 컴파일러 마음이기 때문에 한 줄에 있는 함수 호출순서에 의존해서 코드를 작성하지 말 것
- 해법: 두 함수를 두줄에 따로 호출할 것

#### 기본적으로 한 줄에서 동일한 변수를 여러번 바꾸면 위험

- 함수 매개변수의 평가 순서는 컴파일러마다 다를 수 있음
- 한 함수의 매개변수들이 동일한 변수를 수정할 경우, 결과가 정의되지 않음(undefined behavior)

```c
add(++i, ++i);       /* 어떤 일이 일어날지 정의되지 않음 */
add(i = -1, i = -1); /* 어떤 일이 일어날지 정의되지 않음 */
add(i, i++);         /* 어떤 일이 일어날지 정의되지 않음 */
```

```c
int main(void)
{
    int num = 10;
    num = ++num + num++;
    printf("num: %d\n", num);
}

/* 이런것도 한줄에 여러번 num의 변수를 바꿈.. 이것도 정의되지 않음! undefined behavior*/
```

#### 한 표현식에서 같은 변수를 여러 번 바꾸지 말 것

- '+'연산자는 피연산자의 평가 순서를 강제하지 않음
- '='연산자도 마찬가지
- 이럴 때 한 줄에서 같은 변수를 여러 번 수정하면 정의되지 않은 결과
- 가독성도 안 좋은 코드니 이렇게 하지 말 것
  - 동작이 정의되어 있는지 일일이 확인하는 것도 귀찮은 일

#### 연산자 우선순위와 평가 순서

```c
int main(void)
{
    int num1 = 10;
    int num2 = 20;

    int result = add(num1, num2) + subtract(num1, num2) * divide(num1, num2);
    printf("result: %d\n", result);

    return 0;
}
```

`add(num1, num2)` 와 `subtract(num1, num2)` 그리고 `divide(num1, num2)` 중에 어떤게 먼저 평가가 될까?

- 모름 (컴파일러 마음!)
- '+'연산자보다 '\*'연산자의 우선순위가 높다고 '*'연산자와 인접한 코드가 먼저 평가되는 것이 아님
- 연산자 우선순위와 평가 순서는 서로 아~무 연관이 없음

```c
int i = 0;
int j = 0;
int k = 0;

if (++i || ++j && ++k)
{
    printf("true!\n");
}

printf("%d, %d, %d\n", i, j, k);
```

- 결과: `true!` `1, 0, 0`
- || 와 &&는 시퀀스포인트임! 따라서 ||와 &&앞은 평가를 우선적으로 해야함
- '&&'가 '||'보다 연산에서는 우위이지만 '||'도 시퀀스 포인트이기 때문에 앞의 `++i`를 먼저 평가한다.
- `++i || (++j && ++k)` 연산자 우선순위에 의해 이렇게 묶이는 것은 맞음
  - 하지만 나중에 각 값이 나온 뒤에 어떻게 연산하느냐에 문제
  - 실제 평가되는것은 시퀀스포인트에 따라 `++i`를 먼저 평가한다.
- 따라서 `++i || (++j && ++k)` 의 `++i`가 1이 되어 참이 됨
  - 이미 왼쪽 피연산자가 참이므로 오른쪽 피연산자를 검사할 필요 없음
  - 이런걸 short circuit평가라고 함

##### &&와 ||는 평가 순서를 강제하는 연산자

- 논리 연산자 &&과 ||의 경우 왼쪽 피연산자를 먼저 실행
  - 왼쪽 피연산자의 평가만으로 오른쪽 피연산자를 평가 안 할수도 있음

##### 피연산자 평가 순서 정리

- 한 줄에 있는 피연산자들은 기본적으로 평가 순서가 보장 안 된다고 생각!
- 그리고 ||와 &&는 시퀀스포인트이므로 평가 순서 보장
- 삼항 연산자(?:)와 , ; 도 평가순서 보장
- 함수를 실제 실행하기 전에 모든 매개변수도 평가 됨

## 범위(scope)

- 총 4가지의 범위가 있다
  - 블록 범위
  - 파일 범위
  - 함수 범위
  - 함수 선언 범위

### 블록 범위

- 중괄호({ })안에 선언한 것들은 그 블록 안에서만 사용 가능
- 블록 안에 또 다른 블록을 넣을 수도 있다
  - 그러면 안쪽 블록은 바깥 블록에 접근 가능
  - 그 반대는 안 됨

```c
int maim(void)
{
    int num1 = 10;
    printf("num: %d\n", num1);

    {
        int num2 = 100;
        int result = num1 + num2;
        printf("result: %d\n", result);
    }

    /* num2, result 접근 못 함 */

    return 0;
}
```

#### 블록 범위와 변수 선언 위치

- 함수 중간에 블록을 열고 변수 선언 가능
- 함수 시작 지점에서 모든 변수를 선언하면 실수할 여지가 있음
  - 정확하게 어디서 사용하는 변수인지 파악 불가능
  - 중간에 그 값이 바뀔 수도
- 블록을 이용해서 함수 중간에 선언하는 것도 하나의 방법
- 코딩 표준: 범위가 달라도 모든 변수 이름을 다르게 지을 것
  - 변수 가리기(variable shadowing) 금지

### 파일 범위

- 어떤 블록이나 매개변수 목록에도 안 속하고 파일 안에 있는 것

  ```c
  #include <stdio.h>

  static int s_num = 1024; // 함수 밖에. 파일 위에 덩그러니 있는.. 파일에 속해있는 변수임(Translation Unit)

  int add(int op1, int op2);

  int main(void)
  {
      s_num = add(10, 30);

      return 0;
  }
  ```

- 전역 변수
- 파일 범위에 있는 변수
  - 다른 소스코드 파일에서 링크 가능
  - 프로그램 실행 동안 공간을 차지
    - 즉, 스택 메모리에 들어가는 게 아님
    - 이들은 데이터 섹션에 들어감

### 함수 범위

- 유일한 예: 레이블(lable)
- goto같은 데서 쓰는 것
- 함수 안에서 선언된 레이블은 함수 어디에서라도 접근 가능
  - 다른 범위들은 위에서 선언된 것만 접근 가능했음

#### 함수 선언 범위

- 함수 선언의 매개변수 목록에 있는 것은 그 목록 안에서 접근 가능

```c
void do_something(
    double value,                  /* 함수 선언 범위 */
    char array[10 * sizeof(value)] /* value는 첫 번째 매개변수 */
);
```

## const 키워드

```c
// 예1
int calculate_risk(const int id)
{
    int age = db_get_age(id);
    int amount;

    id *= 2; /* 컴파일 오류 */

    amount = db_get_deposit_amount(id);

    int risk;
    return risk;
}
```

- risk함수의 매개변수인 id에 const선언을 해줌으로써  코드 중간에 `id *= 2;`처럼 값을 변경하려 하면 컴파일 오류가 남

```c
// 예2
void update_dimension(int w, int h, int data[])
{
    int i = 0;
    const int area = w * h;

    area = area + 1; /* 컴파일 오류 */

    for(i = 0; i < area; ++i)
    {
        data[i] = 1;
    }
}
```

- 매개변수 w, h를 연산해 넣은 변수 area의 값에 const키워드를 붙여서 나중에 값을 변경하려 하면 컴파일 오류가 남

### const 베스트 프랙티스

- 기본적으로 모든 변수에 const를 붙이자
  - 실수로 값을 변경하지 않기 위해
- 정말 값 변경이 필요한 변수에만 const를 생략하자
- 원칙적으로 말하면 언어의 기본동작이 바뀌어야 함
  - 아무것도 안 붙이면 const
  - 굳이 프로그래머가 바뀌는 걸 원하면 앞에 뭔가 붙이기

## goto문

```c
goto <label_name>;
...
<label_name>:
```

- C는 위에서 아래로 순차적으로 코드를 실행함
- goto를 쓰면 이 순서를 어기고 다음에 실행할 코드를 마음대로 지정 가능
  - 같은 함수 내에 있는 레이블(lable)로 점프함
- 프로그래머 마음대로!
  - 원하는 코드 실행순서대로 조정할 수 있음
- goto의 (나쁜)예
  
  ```c
  void do_work(void)
  {
  infinity:
    printf("work time!\n");

    goto infinity;   /* infinity로 점프해서 출력하는걸 무한으로 출력 */
  }
  ```

- 또 다른 반복문(do-while)과 goto예

  ```c
  int main(void)
  {
      int counter = 3;
  
      do {
          printf("play time\n");
      } while (counter-- > 0);
      /* --- 위와 같은 동작 ----- */
      counter = 3;

      loop:
          printf("play time\n");
  
          if (counter-- > 0) {
              goto loop;
          }
  }
  ```

  - do-while문과 goto는 어셈블리어도 거의 일치함

### 반복문은 결국 goto를 사용하는 코드

- 어셈블리어에는 반복문이란 게 없음
- 원래 어셈블리어로 프로그래밍하다가 C로 넘어온 거라 초기엔 goto를 많이 사용했음
- 당연히 이보다 안전한 방법이 보통 반복문을 쓰는 것
  - 반복문은 실수를 막기 위해서 나온 것(조건문도 비슷)
  - 따라서 goto를 자주 쓰지는 않음
  - goto보다는 반복문,조건문을 쓰는게 더 안전

### goto는 악마인 것인가

- goto는 악마긴 악마다
- goto를 잘못쓰면 스파게티처럼 꼬인 코드가 나옴
  - 실수, 버그 많이 나옴
- 그러나 goto가 늘 악마인건 아니다.
  - 3중 for문에서 빠져나오려면
  - goto없이 안쪽 for문에서 탈출하려면 쓸데없이 if문을 여러 개 써야 함

#### goto 베스트 프랙티스

- goto문은 언제나 전방(아래쪽)으로만 점프할 것
  - 후방으로 점프하면 스파게티처럼 꼬이기 쉬움
- 내포된(nested)루프에서 빠져나올 때는 자유로이 쓸 것
- 한 함수 안에 있는 여러 개의 조건문이 공통된 코드를 실행해야 할 때도 써도 됨
  - 예: 함수 마지막에 성공/오류 조건 처리

## 배열

- C#과 달리 new를 반드시 사용할 필요가 없음
  - C에는 new키워드가 없음

```c
int nums[5];
char name[10];
float GPAs[3] = { 3.1f, 2.2f, -13.0f };
```

- 배열에 접근하는 법은 C#과 동일(for문)

```c
int nums[5] = {1, 2, 3, 4, 5};
int i;
int sum;

for (i = 0; i < 5; ++i)
{
    nums[i] += i * 2;
}

sum = 0;
for (i = 0; i < 5; ++i)
{
    sum += nums[i];
}
```

## 스택(stack) 메모리

- 우선 자료구조인 스택이랑 헷갈리지 말 것
  - 둘 다 작동방법이 동일해서(LIFO_Last In First Out) 스택이란 이름을 쓸 뿐
- **각 함수에서 사용하는 지역 변수 등을 임시적으로 저장하는 공간**
- 스택 메모리의 크기는 프로그램 **빌드 시**에 결정됨
- 스택 메모리의 위치는 실행 시에 결정됨
- 함수가 호출될 때마다 그 함수에서 필요한 공간을 스택에서 떼어줬다가  
그 함수가 반환하면 그냥 흔들어 지워버리는 개념(실제 지우진 않음)

### 기본 자료형 변수는 스택 메모리를 차지

- 여태까지 모든 기본 자료형 변수(char, int, float)를 new없이 사용할 수 있었던 이유가  
바로 스택 메모리에 할당됐기 때문
  - 컴파일 된 코드 자체가 내 함수에서 정확히 몇 바이트 쓸지 알고있기 때문
- 기본 자료형을 함수 매개변수로 전달하면 스택에 복사본을 만듦
  - 이게 바로 값형
- 스택 메모리를 빌리고 반환할 때마다 언제나 빈 공간 없이 차곡차곡 쌓여 있음
- new로 만든 데이터는 힙(heap) 메모리에 할당됨
  - 이 경우 메모리에 구멍이 숭숭 뚫릴 수 있음
  - 힙 메모리는 운영체제가 그런 빈 공간을 찾아야하기 때문에 스택메모리가 좀 더 빠르다

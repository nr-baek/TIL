# C언어의 기본 문법2

## 함수

- C의 함수 선언은 C#과 거의 동일
- 다만 C는 접근 제어자(예: public, private 등)가 없음
- C의 함수는 기본적으로 모두 전역(global) 함수
- 즉, C의 함수는 어디서든 호출할 수 있음!
- 물론 그걸 제한할 수 있는 키워드가 있음

### 함수 오버로딩

- C에는 함수 오버로딩 없음
- 따라서 함수 명을 다르게 만들어야 함

### 함수 정의의 문제

```c
#include <stdio.h>

int main(void)
{
    foo();
    getchar();
    return 0;
}

void foo(void) /* 컴파일 오류 */
{
    printf("foo called");
}
```

- C는 언제나 위에서 아래로 코드를 훑음
- C89에서 함수 정의가 등장하기 전에 그 함수를 호출하면 컴파일러가 다음과 같이 가정
  - 반환형은 int
  - 그 매개변수는 아무거나 올 수 있음
- 따라서, 나중에 컴파일러가 int가 아닌 다른 것을 반환하는 함수를 찾으면 컴파일 오류를 뱉음
- 함수 호출 전에 함수의 정의를 위치시키면 컴파일 됨
  - 그러나 함수를 만들 때마다 그걸 호출하는 코드 위에 다 위치시켜야하고...  
  100개의 함수면 그 순서에 따라 옮겨야하는 상황이 발생
  - C는 고대언어이기 때문
  - 이럴때는 **함수 선언**을 이용하면 됨.

### 함수 선언

- 함수의 구현체 없이 함수 원형(prototype)만 선언해 주는 것
- 함수 원형은 다음의 사항들을 명시
  1. 함수의 이름
  2. 반환형
  3. 매개변수들의 자료형
- 비교: 함수 정의(definition)는 실제로 함수를 구현해 놓은 것
  - 함수 정의는 그 자체로 함수 선언이기도 함(선언을 내포)

#### 함수 선언과 정의를 분리

```c
void foo(void); /* 함수 선언(전방 선언) */

int main(void)
{
    foo();
    getchar();
    return 0;
}

void foo(void) /* 함수 정의 */
{
    printf("foo called");
}
```

#### 함수 선언과 정의가 하나

```c
#include <stdio.h>

void foo(void) /* 함수 정의(+선언) */
{
    printf("foo called");
}

int main(void)
{
    foo();
    getchar();
    return 0;
}
```

#### 함수 선언의 위치

- 함수를 사용하기 전에 그 함수를 선언
  - 보통 파일의 제일 위에(전방 선언)
  - 혹은, 헤더 파일에(조금 더 좋은 방법)

#### 코딩표준: 함수선언

- 함수가 int를 반환한다 해도 함수선언을 해주자!
- C89/C90에서는 안해도 되긴 함..
- 그러나 C99 표준부터는 int 가정을 하지 않음
  - 어떤 컴파일러는 경고만 주고, 컴파일은 허용할 수도 있음
  - 모든 컴파일러가 그렇다는 보장이 없으므로 반드시 선언할 것

### 함수 매개변수의 평가 순서

- 표준에 따르면, 함수 매개변수의 평가 순서는 명시되어있지 않음(unspecified)
- 즉, 컴파일러에 따라 평가 순서가 달라질 수 있음
  `printf("%d, %d\n", add(num1, num2), subtract(num1, num2));` 의 함수에서  
  add와 subtract 둘 중 어느 매개변수가 먼저 호출될지는 **컴파일러 마음**
- 어느 쪽이 먼저 호출돼도 모두 올바른 동작
- 함수 매개변수의 평가 순서가 컴파일러 마음이기 때문에 한 줄에 있는 함수 호출순서에 의존해서 코드를 작성하지 말 것
- 해법: 두 함수를 두줄에 따로 호출할 것

#### 기본적으로 한 줄에서 동일한 변수를 여러번 바꾸면 위험

- 함수 매개변수의 평가 순서는 컴파일러마다 다를 수 있음
- 한 함수의 매개변수들이 동일한 변수를 수정할 경우, 결과가 정의되지 않음(undefined behavior)

```c
add(++i, ++i);       /* 어떤 일이 일어날지 정의되지 않음 */
add(i = -1, i = -1); /* 어떤 일이 일어날지 정의되지 않음 */
add(i, i++);         /* 어떤 일이 일어날지 정의되지 않음 */
```

```c
int main(void)
{
    int num = 10;
    num = ++num + num++;
    printf("num: %d\n", num);
}

/* 이런것도 한줄에 여러번 num의 변수를 바꿈.. 이것도 정의되지 않음! undefined behavior*/
```

#### 한 표현식에서 같은 변수를 여러 번 바꾸지 말 것

- '+'연산자는 피연산자의 평가 순서를 강제하지 않음
- '='연산자도 마찬가지
- 이럴 때 한 줄에서 같은 변수를 여러 번 수정하면 정의되지 않은 결과
- 가독성도 안 좋은 코드니 이렇게 하지 말 것
  - 동작이 정의되어 있는지 일일이 확인하는 것도 귀찮은 일

#### 연산자 우선순위와 평가 순서

```c
int main(void)
{
    int num1 = 10;
    int num2 = 20;

    int result = add(num1, num2) + subtract(num1, num2) * divide(num1, num2);
    printf("result: %d\n", result);

    return 0;
}
```

`add(num1, num2)` 와 `subtract(num1, num2)` 그리고 `divide(num1, num2)` 중에 어떤게 먼저 평가가 될까?

- 모름 (컴파일러 마음!)
- '+'연산자보다 '\*'연산자의 우선순위가 높다고 '*'연산자와 인접한 코드가 먼저 평가되는 것이 아님
- 연산자 우선순위와 평가 순서는 서로 아~무 연관이 없음

```c
int i = 0;
int j = 0;
int k = 0;

if (++i || ++j && ++k)
{
    printf("true!\n");
}

printf("%d, %d, %d\n", i, j, k);
```

- 결과: `true!` `1, 0, 0`
- || 와 &&는 시퀀스포인트임! 따라서 ||와 &&앞은 평가를 우선적으로 해야함
- '&&'가 '||'보다 연산에서는 우위이지만 '||'도 시퀀스 포인트이기 때문에 앞의 `++i`를 먼저 평가한다.
- `++i || (++j && ++k)` 연산자 우선순위에 의해 이렇게 묶이는 것은 맞음
  - 하지만 나중에 각 값이 나온 뒤에 어떻게 연산하느냐에 문제
  - 실제 평가되는것은 시퀀스포인트에 따라 `++i`를 먼저 평가한다.
- 따라서 `++i || (++j && ++k)` 의 `++i`가 1이 되어 참이 됨
  - 이미 왼쪽 피연산자가 참이므로 오른쪽 피연산자를 검사할 필요 없음
  - 이런걸 short circuit평가라고 함

##### &&와 ||는 평가 순서를 강제하는 연산자

- 논리 연산자 &&과 ||의 경우 왼쪽 피연산자를 먼저 실행
  - 왼쪽 피연산자의 평가만으로 오른쪽 피연산자를 평가 안 할수도 있음

##### 피연산자 평가 순서 정리

- 한 줄에 있는 피연산자들은 기본적으로 평가 순서가 보장 안 된다고 생각!
- 그리고 ||와 &&는 시퀀스포인트이므로 평가 순서 보장
- 삼항 연산자(?:)와 , ; 도 평가순서 보장
- 함수를 실제 실행하기 전에 모든 매개변수도 평가 됨

## 범위(scope)

- 총 4가지의 범위가 있다
  - 블록 범위
  - 파일 범위
  - 함수 범위
  - 함수 선언 범위

### 블록 범위

- 중괄호({ })안에 선언한 것들은 그 블록 안에서만 사용 가능
- 블록 안에 또 다른 블록을 넣을 수도 있다
  - 그러면 안쪽 블록은 바깥 블록에 접근 가능
  - 그 반대는 안 됨

```c
int maim(void)
{
    int num1 = 10;
    printf("num: %d\n", num1);

    {
        int num2 = 100;
        int result = num1 + num2;
        printf("result: %d\n", result);
    }

    /* num2, result 접근 못 함 */

    return 0;
}
```

#### 블록 범위와 변수 선언 위치

- 함수 중간에 블록을 열고 변수 선언 가능
- 함수 시작 지점에서 모든 변수를 선언하면 실수할 여지가 있음
  - 정확하게 어디서 사용하는 변수인지 파악 불가능
  - 중간에 그 값이 바뀔 수도
- 블록을 이용해서 함수 중간에 선언하는 것도 하나의 방법
- 코딩 표준: 범위가 달라도 모든 변수 이름을 다르게 지을 것
  - 변수 가리기(variable shadowing_각 다른 범위에 같은 이름의 변수를 사용하는 것) 금지

### 파일 범위

- 어떤 블록이나 매개변수 목록에도 안 속하고 파일 안에 있는 것

  ```c
  #include <stdio.h>

  static int s_num = 1024; // 함수 밖에. 파일 위에 덩그러니 있는.. 파일에 속해있는 변수임(Translation Unit)

  int add(int op1, int op2);

  int main(void)
  {
      s_num = add(10, 30);

      return 0;
  }
  ```

- 전역 변수
- 파일 범위에 있는 변수
  - 다른 소스코드 파일에서 링크 가능
  - 프로그램 실행 동안 공간을 차지
    - 즉, 스택 메모리에 들어가는 게 아님
    - 이들은 데이터 섹션에 들어감

### 함수 범위

- 유일한 예: 레이블(lable)
- goto같은 데서 쓰는 것
- 함수 안에서 선언된 레이블은 함수 어디에서라도 접근 가능
  - 다른 범위들은 위에서 선언된 것만 접근 가능했음

#### 함수 선언 범위

- 함수 선언의 매개변수 목록에 있는 것은 그 목록 안에서 접근 가능

```c
void do_something(
    double value,                  /* 함수 선언 범위 */
    char array[10 * sizeof(value)] /* value는 첫 번째 매개변수 */
);
```

## const 키워드

```c
// 예1
int calculate_risk(const int id)
{
    int age = db_get_age(id);
    int amount;

    id *= 2; /* 컴파일 오류 */

    amount = db_get_deposit_amount(id);

    int risk;
    return risk;
}
```

- risk함수의 매개변수인 id에 const선언을 해줌으로써  코드 중간에 `id *= 2;`처럼 값을 변경하려 하면 컴파일 오류가 남

```c
// 예2
void update_dimension(int w, int h, int data[])
{
    int i = 0;
    const int area = w * h;

    area = area + 1; /* 컴파일 오류 */

    for(i = 0; i < area; ++i)
    {
        data[i] = 1;
    }
}
```

- 매개변수 w, h를 연산해 넣은 변수 area의 값에 const키워드를 붙여서 나중에 값을 변경하려 하면 컴파일 오류가 남

### const 베스트 프랙티스

- 기본적으로 모든 변수에 const를 붙이자
  - 실수로 값을 변경하지 않기 위해
- 정말 값 변경이 필요한 변수에만 const를 생략하자

## goto문

```c
goto <label_name>;
...
<label_name>:
```

- C는 위에서 아래로 순차적으로 코드를 실행함
- goto를 쓰면 이 순서를 어기고 다음에 실행할 코드를 마음대로 지정 가능
  - 같은 함수 내에 있는 레이블(lable)로 점프함
- 프로그래머 마음대로!
  - 원하는 코드 실행순서대로 조정할 수 있음
- goto의 (나쁜)예
  
  ```c
  void do_work(void)
  {
  infinity:
    printf("work time!\n");

    goto infinity;   /* infinity로 점프해서 출력하는걸 무한으로 출력 */
  }
  ```

- 또 다른 반복문(do-while)과 goto예

  ```c
  int main(void)
  {
      int counter = 3;
  
      do {
          printf("play time\n");
      } while (counter-- > 0);

      /* --- 위와 같은 동작 ----- */
      
      counter = 3;

      loop:
          printf("play time\n");
  
          if (counter-- > 0) {
              goto loop;
          }
  }
  ```

  - do-while문과 goto는 어셈블리어도 거의 일치함

### 반복문은 결국 goto를 사용하는 코드

- 어셈블리어에는 반복문이란 게 없음
- 원래 어셈블리어로 프로그래밍하다가 C로 넘어온 거라 초기엔 goto를 많이 사용했음
- 당연히 이보다 안전한 방법이 보통 반복문을 쓰는 것
  - 반복문은 실수를 막기 위해서 나온 것(조건문도 비슷)
  - 따라서 goto를 자주 쓰지는 않음
  - goto보다는 반복문,조건문을 쓰는게 더 안전

### goto는 악마인 것인가

- goto는 악마긴 악마다
- goto를 잘못쓰면 스파게티처럼 꼬인 코드가 나옴
  - 실수, 버그 많이 나옴
- 그러나 goto가 늘 악마인건 아니다.
  - 3중 for문에서 빠져나오려면
  - goto없이 안쪽 for문에서 탈출하려면 쓸데없이 if문을 여러 개 써야 함

#### goto 베스트 프랙티스

- goto문은 언제나 전방(아래쪽)으로만 점프할 것
  - 후방으로 점프하면 스파게티처럼 꼬이기 쉬움
- 내포된(nested)루프에서 빠져나올 때는 자유로이 쓸 것
- 한 함수 안에 있는 여러 개의 조건문이 공통된 코드를 실행해야 할 때도 써도 됨
  - 예: 함수 마지막에 성공/오류 조건 처리

## 배열

- C#과 달리 new를 반드시 사용할 필요가 없음
  - C에는 new키워드가 없음

```c
int nums[5];
char name[10];
float GPAs[3] = { 3.1f, 2.2f, -13.0f };
```

- 배열에 접근하는 법은 C#과 동일(for문 사용하는 것도 동일)

```c
int nums[5] = {1, 2, 3, 4, 5};
int i;
int sum;

for (i = 0; i < 5; ++i)
{
    nums[i] += i * 2;
}

sum = 0;
for (i = 0; i < 5; ++i)
{
    sum += nums[i];
}
```

## 스택(stack) 메모리

- 우선 자료구조인 스택이랑 헷갈리지 말 것
  - 둘 다 작동방법이 동일해서(LIFO_Last In First Out) 스택이란 이름을 쓸 뿐
  - 메모리에 데이터가 차곡차곡 쌓이고 반환도 마지막 들어온 데이터 부터 차례로 됨
- **각 함수에서 사용하는 지역 변수 등을 임시적으로 저장하는 공간**
- 스택 메모리의 크기는 프로그램 **빌드 시**에 결정됨
- 스택 메모리의 위치는 실행 시에 결정됨
- 함수가 호출될 때마다 그 함수에서 필요한 공간을 스택에서 떼어줬다가  
그 함수가 반환하면 그냥 흔들어 지워버리는 개념(실제 지우진 않음)

### 기본 자료형 변수는 스택 메모리를 차지

- 여태까지 모든 기본 자료형 변수(char, int, float)를 'new'없이 사용할 수 있었던 이유가  
바로 스택 메모리에 할당됐기 때문
  - 컴파일 된 코드 자체가 해당 함수에서 정확히 몇 바이트 쓸지 알고있기 때문
- 기본 자료형을 함수 매개변수로 전달하면 스택에 복사본을 만듦
  - 이게 바로 값형
- 스택 메모리를 빌리고 반환할 때마다 언제나 빈 공간 없이 차곡차곡 쌓여 있음
- new로 만든 데이터는 힙(heap) 메모리에 할당됨
  - 이 경우 메모리에 구멍이 숭숭 뚫릴 수 있음
  - 중간에 할당된 메모리가 반환되어 비어있는 공간이 생김
  - 힙 메모리는 운영체제가 그런 빈 공간을 찾아서 할당하기 때문에 힙메모리 보다는 스택메모리가 좀 더 빠르다

### 스택 메모리의 구조

- 스택은 큰 주소에서 작은 주소로 쌓임
- ESP(Extended Stack Pointer)
  - 현재 스택 포인터
  - 현재 스택이 어디까지 차있는지 보여주는 포인터
- EBP(Extended Nase Pointer)
  - 현재 스택 프레임의 기본(첫) 주소
- 스택 프레임(stack frame)
  - EBP~ESP가 가리키는 범위
  - 각 함수가 사용하는 스택 메모리의 범위
  - 그 범위의 크기는 컴파일중에 결정됨
- 스택의 크기
  - 한정적
  - 타겟 플랫폼 따라 달라짐
  - clang windows에서 아무것도 안 정해주면 대략 1MB정도 됨
- 스택 오버플로
  - 정해진 스택메모리보다 더 많은 양을 사용하려고 하면 문제가 생김
  - 따라서 너무 큰 데이터를 사용할 때는 스택에 넣을 수 없음
  - 이럴 경우에 사용하는 것이 **동적 메모리** 할당(C#에서는 new를 사용)
    - OS에게 메모리 달라고 부탁하는 것
  - 재귀 함수를 너무 깊게 호출 하면 스택 오버플로 남
    - 같은 이유
    - 함수 한 번 호출할 때마다 그 함수 스택 프레임만큼의 바이트를 더 먹음
    - 그 함수가 반환하지 않고 계속 다른 함수를 호출하며 스택을 올리다보면
    - 언젠가 이 1MB 공간을 다 씀

### sizeof( )

```c
int values[30];
size_t array_size = sizeof(values);  /* 120 */
```

- sizeof(values)는 values 배열이 **차지하는 총 바이트 수**를 반환
- 그 이유는?
  - 이 배열이 스택에서 몇 바이트를 차지하는지 **컴파일 중**에 알기 때문

#### sizeof( )를 이용한 꼼수: 배열의 요소 개수 구하는 방법

##### 방법1

`const size_t num_vals = sizeof(values) / sizeof(vlaues[0]);`

- 배열이 실제 차지하는 바이트 수 `sizeof(values)` 나누기 한 요소 당 크기 `sizeof(vlaues[0])`
  - 총 요소가 몇 개 들어가는지 값이 나옴

##### 방법2

```c
/* 함수 밖에서 */
#define ARRAY_LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))

/* 매크로 함수 사용 */
const size_t num_vals2 = ARRAY_LENGTH(values);
```

- 이렇게 매크로 함수를 이용해서 현재 스택에 있는 배열의 요소 개수를 구하는 코드를 쉽게 만들 수도 있음

#### sizeof( 매개변수 )와 배열의 총 바이트 수

- sizeof( )가 매개변수로 들어온 배열의 총 바이트 수를 반환할 수 있으려면
  - 그 배열의 모든 요소가 스택에 다 복사되어 전달돼야 함
  - 그리고 호출되는 함수는 스택에 복사된 모든 요소의 크기를 정확히 알아야 함
- 그러나 함수의 스택 메모리 사용량은 고정
  - 함수는 호출자가 누구든 간에 **딱 정해진 수와 크기의 매개변수**가 들어온단 가정으로 동작
  - 함수가 먼저 결정되고, 호출자는 그 함수를 호출할 뿐
  - 즉, 함수는 호출자가 뭐하는 놈인지 모름

##### 예) sizeof( ): 다르게 나오는 배열의 크기

- 배열의 경우, 함수 인자로 받을 경우 다른 결과가 나옴

```c
size_t get_char_array_size(char data[])
{
    return sizeof(data);
}

int main(int argc, char** argv)
{
    char char_array[30];

    size_t size_array = sizeof(char_array);  /* 30 */
    size_t size_array_2 = get_char_array_size(char_array);   /* 4 */
}
```

###### get_char_array_size(char_array)가 4를 반환한 이유

- sizeof( )는 함수가 아닌 연산자! 때문에 컴파일 도중에 크기를 찾음
- 그러나 함수의 스택 메모리 사용량은 고정!
- **딱 정해진 수와 크기의 매개변수가 들어온단 가정**으로 동작
  - 배열을 함수의 매개변수로 전달할 때는 실제 모든 요소를 스택에 넣지 않음
  - 그 대신 그 배열의 _시작 위치(주소)_ 를 스택에 넣어 줌
    - 이 주소의 크기 = 포인터 데이터형의 크기
    - 32비트 플랫폼에서는 4바이트, 64비트에서는 8바이트
    - 그래서 sizeof()를 하면 4바이트가 나온 것

##### 길이가 명시된 매개변수 배열

```c
void process(int num[5]) {
    size_t i;
    for (i = 0; i < 5; ++i) {
        num[i] *= 2;
    }
}
```

###### 위와 같이 process함수의 매개변수로 `(int num[5])`를 넣으면 컴파일러는 길이가 5인 배열로 볼까

- 길이가 5라는걸 명시해 놨으니 컴파일러가 배열의 크기 알고서 그 만큼 스택 메모리를 잡아놓지 않을까?
  - NO! 이건 프로그래머의 편의를 위한 것일 뿐
  - 프로그래머 읽기 편하라고 [5]를 써준 것(문서화한 개념일 뿐)
  - 컴파일 하면 `void process(int num[ ])`와 동일!
    - 함수의 인자로 받은 배열은 여전히 정해진 크기의 매개변수로 보기 때문에
    - 배열의 주소를 스택에 넣어줄 뿐

###### 원본 배열이 바뀌는 코드

- 이처럼 위 코드는 복사본이 아니라 원본을 바꿈
  - '참조에 의한 호출'로 보는 사람이 있고 '값에 의한 호출'로 보는 사람도 있음
  - 어쨌든, 원본이 바뀐다는 것!

##### 매개변수 배열의 길이를 알 방법은 없다

- 배열 자체에서 크기를 알아올 수 있는 방법은 없음
  - 예외: ARRAY_LENGTH( ) 꼼수 매크로를 쓸 수 있는 경우
- 즉, 배열의 크기는 따로 기억해둬야 한다.

```c
void process(size_t n, int num[]) {
    size_t i;
    for (i = 0; i < n; ++i) {
        num[i] *= 2;
    }
}
```

- 이렇게 해야 좀 더 안전한 것
- 배열의 요소 수는 호출자가 직접 넣도록.

#### 배열 요소의 초깃값

- C는 배열 요소의 값을 초기화해주지 않음(C#은 0으로 해줬음)
- 따라서 그 전에 그 메모리에 남아있던 값을 그대로 사용(쓰레기값)
  - 이건 변수도 마찬가지

  ```c
  int num[30]; /* 속에 뭔 값이 들어있는지 모름 (쓰레기값) */
  int val;     /* 마찬가지 */
  ```

- 배열 요소를 초기화 하는 법

```c
int nums1[4]; /* 쓰레기만 잔뜩 */
int nums2[4] = { 10, 15, 3, -1 }; /* 모두 초기화 됨 */
int nums3[4] = { 10, 15 };    /* 10, 15, 0, 0 */
int nums4[2] = { 10, 15, 3 }; /* 컴파일 오류 */
int nums5[] = { 10, 15, 3 };  /* 배열의 크기 = 3, 컴파일러가 배열의 크기를 결정*/
```

##### 베스트 프랙틱스: 배열의 모든 값을 0으로

`int nums[10] = { 0, };`

- **0뒤에 쉼표를 찍자**
- 이를 통해 초기화 목록이 모든 값을 직접 초기화해주진 않지만 쉼표 뒤가 모두 0으로 초기화됨을 보여줌

#### C의 위험성

- 초기화 안 된 지역 변수를 모른 채 사용할 수 있음
  - 배열 요소 포함
- 버퍼 오버플로도 가능
  - 아무도 버퍼 오버플로가 있다고 체크해주지 않음

  ```c
  int buffer[2] = { 2, 2 };
  int buffer2[2] = { 1, 1 };
  size_t i;

  for(i = 0; i <= 2; ++i) {
      buffer2[i] = 0;
  }
  ```

  - `i <= 2`로 표현식을 잘못 작성 함!
  - `buffer2[i] = 0;` 코드를 보면 buffer2의 배열 요소만 0으로 바꾸는 것 같지만
  - `i <= 2`표현식 때문에 `buffer2[2] = 0;`도 실행이 됨
  - buffer2[2]는 없지만 스택 메모리상의 buffer2[1] 다음 자리인 buffer[0]의 메모리가 지목됨
  - 원치 않던 buffer[0]의 요소도 0으로 바뀌게 됨.
  - 이렇게 건드리지 말아야 할 메모리값을 건드려서 문제가 생김
  - memory stomp라는 버그임

## 다차원 배열

- 2차원이나 3차원 배열 같은 것
- 2차원 배열의 경우 C#에서는 int[ , ], C에서는 int[ ][ ]
- **2차원 배열을 1차원으로 바꾸는것**을 원활히 할 줄 알아야 함

```c
int table[2][3];


for (int i = 0; i < 2; ++i)
{
    for (int j = 0; j < 3; ++j)
    {
        table[i][j] = (i + 1)*(j + 1);
    }
}
```

- 6개의 요소가 3칸씩 두 줄로 되어있는게 아닌 메모리상에는 일렬로 촘촘히 순서대로 들어가 있음(1차원과 다르지 않음)
- 2차원의 데이터를 1차원으로 바꿔 접근 할 수 있음

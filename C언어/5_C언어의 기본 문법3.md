# C언어의 기본 문법3_소스코드에서 실행파일까지

## C프로그램의 빌드 과정

- 빌드(build)란 무엇인가?
  - 사람이 읽기 쉬운 소스코드를 기계어 명령어로 변환하는 과정
  - 그리고 그 명령어들을 모아 기계에서 실행 가능한 실행파일로 만드는 과정
- C의 빌드는 4단계로 나뉘어져 있음
  1. 전처리(preprocessing)
  2. 컴파일(compilation)
  3. 어셈블(assembling)
    (1~3번을 합쳐 '컴파일'이라 하기도 함)
  4. 링크(linking)

`> clang -std=c89 -W -Wall -pedantic-errors *.c`

- 보통 커맨드라인에서 이렇게 빌드를 함
- 그러면 clang이 알아서 모든 4단계를 실행해 줌
  - 결과는 최종 실행파일(.exe, .out)
  - clang에서 한 단계씩 실행도 가능하다

### 소스코드의 구성

- C# - `adder.cs` `main.cs`
- C - `main.c` `adder.h` `adder.c`
  - adder파일이 h와 c로 나눠져 있다!
  - C는 고대언어이기 때문에 헤더파일과 c를 나눠놨다.

#### 두 종류의 소스코드 파일(.h와 .c)

##### C파일(.c)

- (우리가 생각하는 일반적인 소스코드 파일)
- 실제 프로그램을 돌게 하는 로직 코드를 저쟁해 두는 파일
- 내용물
  - 함수 정의(= 함수구현)
  - 전역 변수 등
  - 매크로

##### 헤더 파일(.h)

- 여러 소스코드 파일에 (공유하고 싶은 코드)공통적으로 필요한 것들을 저장해 두는 파일
- 내용물
  - 함수 선언
  - 매크로
  - extern 변수 선언 등
- .c파일에 **#include**로 포함함
  (예: `#include "adder.h"`)
- 사실 모든 소스코드를 .c파일 하나에 집어넣을 수도 있음
  - 그러나 코드가 100만줄이라면 난장판이 됨
- 문명인은 난장판 보다 적당히 정돈된 것을 좋아한다
  - 따라서 연관된 기능끼리 모아서 .c파일 하나씩 저장
  - 그러다 보면 논리적으로 분리된 여러 .c파일이 생김
- 이때 동이한 함수를 여러 곳에서 써야 한다면 복붙을 해야 할까?
  - NO! 코드중복!
  - 유지보수 잘 안됨
- 헤더 파일을 사용하면 함수 선언을 여러 C파일들과 공유 가능

##### 함수 선언만 가지고 어떻게 프로그램이 작동할까

- 빌드가 여러 단계로 쪼개져 있는 이유가 바로 정의 없이 선언만 가지고도 컴파일이 되게 하기 위해서 임
- 그리고 실제 올바른 기능 호출은 링크 단계가 책임짐

##### .c와 .h 파일 사용예: main과 adder

```c
/* adder.h */
int add(const int a, const int b);
```

```c
/* adder.c */
#include "adder.h"

int add(const int a, const int b)
{
    return a + b;
}
```

```c
/* main.c */
#include "adder.h"

int main(void)
{
    const int res = add(1,2);
    return 0;
}
```

- main함수에서 add함수를 호출하려면 add() 함수의 원형(함수의 선언)을 알아야 함
- adder.h에 add()의 원형을 저장
- add()의 최종 기능은 adder.c에 저장
  - 이렇게 하면 혹시 함수 기능을 수정해야 할 때도 원형은(헤더파일에) 그대로 유지
- main.c에서 `#include "adder.h"`만 하면 충분

#### #include < > vs #include "  "

- 인클루드 하는 법은 두 가지가 있음
- 이 둘의 차이는 디스크 상의 어디에서 헤더 파일을 찾느냐 차이

##### #include < >

- < >는 시스템 경로에서만 헤더 파일을 검색
  - 보통 컴파일러가 제공하는 시스템 헤더 파일을 인클루드할 때 사용(c에서 자체적으로 제공하는 기본 라이브러리 사용할 때)
  `#include <stdio.h>`

##### #include " "

- ""는 현재 작업 중인 디렉터리(working directory)에서 파일을 먼저 검색한 뒤 없으면 시스템 경로를 검색
  - 개발자가 구현한 헤더 파일들을 인클루드할 때 사용
  `#include "adder.h"`

## 빌드과정

```c
소스코드(.h, .c)
        -> [전처리기]
확장된 소스 코드
        -> [컴파일러]
어셈블리 코드
        -> [어셈블러]
오브젝트 코드
        -> [링커]
머신 코드 실행파일(.exe,.out)
```

### 전처리 단계

`소스코드(.h,.c) -> [ 전처리기 ] -> 확장된 소스 코드(트랜스레이션 유닛)`

- 보통 전처리기(preprocessor)라는 별도의 프로그램이 담당

1. **입력**

    - 입력: c파일 하나를 입력
2. **처리 과정1**

    - 주석 제거
3. **처리 과정2**

    - 매크로를 복붙 확장함
4. **처리 과정3**

    - 인클루드 파일들을 복붙 확장함
    - #include "헤더 파일"을 지우고 그 자리에 헤더파일 속에 있는 내용을 복사해서 가져다 붙이는 것
5. **출력**

    - 출력: 확장된 소스코드
    - 컴파일의 기본 단위인 **트랜슬레이션 유닛(translation unit)**

#### 트랜슬레이션 유닛 보는 방법

- clang 컴파일 중에 -E 플래그를 넣으면 됨  
  `> clang -std=c89 -W -Wall -pedantic-errors -E adder.c`
- 결과는 화면에 출력
- 파일로 저장하려면 출력 리디렉션(output redirection)을 쓰면 됨
  `> clang -std=c89 -W -Wall -pedantic-errors -E adder.c > adder.pre`

### 컴파일 단계

`확장된 소스 코드(트랜스레이션 유닛) -> [ 컴파일러 ] -> 어셈블리 코드`

- 컴파일러(compiler)라는 프로그램이 담당

1. **입력**

    - 입력: 트랜슬레이션 유닛
2. **출력**

    - 출력: 어셈블리어 코드
    - 어셈블리어는 기계 코드와 거의 1:1로 대응(하드웨어에 아주 가까움)
    - 그러나 텍스트 파일이어서 사람이 여전히 읽을 수 있는 언어
    - 기계가 이해하는 언어는 아님
    - 어셈블리어 코드는 아직 정의를 모르는 심볼을 사용할 수 있음
      - 심볼(symbol): 함수나 변수의 이름 등
      - 이것이 바로 헤더를 통한 선언만으로 컴파일이 가능한 이유!
    - 컴파일러가 어떤 함수나 변수의 정의를 못 찾을 경우
      - 선언만 보고 다음과 같이 행동함

      ```c
      컴파일러
      : 어? 이 함수랑 변수 정의가 없네?
        뭐, 어딘가에 있겠지?
        나중에 이 함수나 변수의 주소는 다른 누군가 채워 넣어 주겠지?
        일단 구멍으로 남겨놔야겠다.
      ```

    - 그 구멍을 채우는 건 링크 단계가 해 줌!

#### 어셈블리어 코드 보는 방법

- 컴파일 플래그 -S를 쓰면 어셈플리어 코드가 .s파일로 저장됨  
  `> clang -std=c89 -W -Wall -pedantic-errors -S adder.c`

#### 어셈블리어 코드가 나왔다는 의미는

- 이 단계 이후부터 코드는 특정 플랫폼에서만 동작한다는 이야기
  - 어셈블리어로 컴파일이 되는 순간 특정 기계에서만 동작
- C가 크로스 플랫폼이라는 주장은 컴파일되기 전까지만 임!
  - 소스코드일때는 윈도우, 맥, 리눅스 등등 다 돔
- 또한 타겟 플랫폼이 몊 비트냐에 따라 C의 자료형 크기가 달라질 수 있음
  - 어셈블리어 코드는 이미 그 자료형 크기가 결정된 후임

### 어셈블 단계

`어셈블리 코드 -> [어셈블러] -> 오브젝트 코드`

- 어셈블러(assembler)라는 프로그램이 담당

1. **입력**

    - 입력: 어셈블리어 코드
2. **출력**

    - 출력: 오브젝트 코드(object code)
    - 오브젝트 코드란?
      - 기계가 곧바로 이해 가능한 기계코드(machine code)
      - 기계어(machine instruction)라고도 한다
      - 즉, 이진코드
      - 어셈블리어 코드와 마찬가지로 여전히 메꿔야 하는 구멍이 있음

#### 오브젝트 코드 보는 방법

- -c 플래그를 넣어서 컴파일하면 .o파일로 저장됨  
  `> clang -std=c89 -W -Wall -pedantic-errors -c main.c`
- 이 파일은 일반 텍스트 편집기에서 보면 제대로 보이지 않음
  - 이진 파일이기 때문!
  - 16진수 편집기로 봐야 함.

### 링크 단계

`오브젝트 코드 -> [ 링커 ] -> 머신 코드 실행파일(.exe,.out)`

- 링커(linker)라는 프로그램이 담당

1. **입력**

    - 입력: 모든 오브젝트 코드들
2. **처리과정**

    - 링커는 모든 오브젝트 코드들을 모아다 구멍을 메꾼 뒤 실행파일로 저장
      - 링커가 오브젝트 파일을 다 모아서 하나의 이진(binary)파일로 만들면서 각 함수의 위치를 기억하고 있다가
      - 함수를 호출하려는 코드를 만나면 실행위치에 기억해둔 함수의 위치(주소)로 점프하는 코드를 넣어줌
    - 만약 선언만 믿고 사용한 함수나 변수가 여전히 구멍으로 남아 있다면?  
    (즉, 다른 오브젝트 코드에서 정의를 못 찾았다면?)
      - 링커가 못 찾는다며 링커 오류를 뱉음
      - 그 함수나 변수가 없어 실행할 방법이 없기에 경고가 아니라 오류
      - 링커에러 나오는경우: 함수원형에서 만들어놓은 것과 똑같은 함수를 만들지 않은 것(뭔가 틀렸거나 c파일을 지웠거나..)
      - exe파일 나오지도 않음
3. **출력**

    - 출력: 최종 실행파일(.exe, .out)

### 링크단계가 분리되어 있는 이유

- 사람들은 보통 컴파일(전처리,컴파일,어셈블)과 링크, 두 단계로 나눠서 생각

- .c 파일이 많이 있으면 구멍 메꿔주는 일이 매우 복잡
  - 예: .c파일이 수 천개나 있는 프로젝트에서 .c 파일 하나 컴파일할 때마다 모든 함수를 찾아서 구멍을 메꿔주려먼 시간이 아주 오래걸림
- 여러 개의 .c 파일에서 동일한 외부 함수를 사용할 경우 최종 실행파일에 그 함수 정의가 중복으로 들어가는 것도 막아야 함
  - 컴파일 단계에서 이 중복을 해결하는 것도 복잡 애매
- 그렇다고 c파일을 한 번에 합쳐서 컴파일 한다면..?
  - 그러면 조금만 수정해도 모든 걸 다 컴파일해야함
- 결과적으로 .c파일 하나씩 따로 컴파일해서 오브젝트 파일로 저장해 두는 방법이 낫다
  - 나중에 바뀐.c파일만 컴파일해서 새로운 오브젝트 파일 생성
  - 기존에 있던 오브젝트 파일들과 합쳐서 링크
  - 이렇게 하면 훨씬 빠르다!
  - 또한 분리시켜 놓으니 간단하고 각자의 파일의 할 일이 명확하게 분리된다.

#### .o파일 .exe파일로 만들기

- 실제로 업계에서는 .o파일을 따로 저장한 후 .o파일을 합쳐서 .exe파일을 만드는 경우가 흔함
- 비주얼 스튜디오에서는 기본적으로 오브젝트 파일과 .exe파일을 모두 만들어 줌
- clang은 그냥 바로 .exe파일만 만들어줄 뿐..
- clang에서 .o파일로 .exe파일 만드는 방법
  - .o파일을 직접 명시하면 됨
    `> clang -std=c89 -W -Wall -pedantic-errors main.o adder.o`  
    혹은 `> clang -std=c89 -W -Wall -pedantic-errors *.o`
- 만약 링크하면서 .o파일을 누락했으면 정의를 찾을 수 없다는 링크에러를 띄움

#### 파일을 라이브러리로 빌드하기

- 빌드 결과가 실행파일이 아니라 라이브러리 파일이 나오게 할 수도 있다
- 라이브러리(library)란?
  - 함수들을 기계어로 변환 후 파일 하나로 저장해 놓은 것
  - 나중에 다른 .c파일에서 이 기능이 필요할 때 같이 링크해서 쓸 수 있음
- 라이브러리는 두 종류가 있음
  - 정적(static) 라이브러리
  - 동적(dynamic) 라이브러리

##### 정적 라이브러리와 링크

- 정적 라이브러리와 링크하는 것을 정적 링킹이라고 함
  - 정적 라이브러리를 한번 만들어 놓으면 새로 컴파일 할 필요 없이 누구나 가져가 링크해 쓸 수 있다
- 라이브러리 안에 있는 기계어를 최종 실행파일에 가져다  복사함
- 동적 링킹에 비해서
  - 실행파일의 크기가 커짐
  - 메모리를 더 잡아먹을 수 있음
  - 실행 속도가 빠름

##### 동적 라이브러리와 링크

- 동적 라이브러리와 링크하는 것을 동적 링킹이라고 함
- 실행파일 안에 여전히 구멍을 남겨두는 방법
  - 실행하면 필요한 함수마다 그때 링킹
- 실행파일을 실행할 때 실제로 링킹이 일어남
  - 이 링킹은 실행 중에 운영체제가 해 줌
  - 실행 중인 실행파일과 동적 라이브러리가 여전히 각각 다른 파일로 구분됨
- .dll파일이 동적 라이브러리 파일
- 정적 링킹에 비해서
  - 실행파일 크기가 작다
  - 여러 실행파일이 동일한 라이브러리를 공유할 수 있다
    - 메모리 절약
  - 여러 실행파일이 이름은 같지만 버전이 다른 동적 라이브러리를 사용한다면 DLL지옥을 맞볼 수 있다
    - 보안 프로그램을 A은행에서 깔면 B은행이 크래시 나고 B은행에서 깔면 A은행이 크래시 나는 경우(버전 충돌)

### 분할 컴파일과 전역변수

#### 여러 개의 파일과 C 빌드

여러 개의 파일을 컴파일 하려면 어떻게 해야 할까?

#### 분할 컴파일

1. 2개 이상의 .c파일을 개별적으로 컴파일해서 오브젝트 파일을 만듦(따로따로 컴파일)
2. 오브젝트 파일들을 서로 연결시켜(링크해서) 실행파일을 만듦

- 그러나 분할 컴파일을 하다보면 오류가 생길 때가 있음!

#### 분할 컴파일 오류가 나는 경우

```c
/* monster_repo.h */
void add_monster(void);
```

```c
/* monster_repo.c */
#include "monster_repo.h"

int g_mob_count = 0;

void add_monster(void)
{
    ++g_mob_count;
}
```

```c
/* main.c */
#include <stdio.h>
#include "monster_repo.h"

int main(void)
{
    add_monster();
    printf("# monsters: %d\n", g_mob_count);

    return 0;
}
```

- 컴파일 해보면 오류가 난다.  
  `error: use of undeclared identifier 'g_mob_count' ...`
  - 선언되지 않은 이름을 썼다는 내용 `g_mob_count`
- 컴파이러가 각.c파일을 따로따로 컴파일 하기 때문
- main.c파일은 monster_repo.c안에 있는 'g_mob_count'의 존재를 모름

**그럼 main.c파일에 `int g_mob_count = 0;`을 넣어주면 될까?**

- 컴파일은 되지만 링커가 실망함...
  - monster_repo.o의 전역변수와 똑같은 전역변수가 main.o에도 있으니 링커 오류 발생
- C에서는 동일한 이름을 가진 전역변수를 여러군데 만들 수 없음
  - 비슷한 개념으로 함수 오버로딩이 안되는 점
- 링커 오류
  - monster_repo.c에도 g_mob_count가 있고 main.c에도 g_mob_count가 있음
  - 컴파일 동안에는 서로를 모르니 잘 됨
  - 링크하려고 하니 전역 범위에 같은 이름 쓰는 변수가 둘이 있음
  - 오류!

**다른 방법이 필요!**

- 따라서 새로운 전역변수를 만드는 게 아니라 _monster_repo.c안에 있는 것을 가져다 쓸 거다_ 라고 컴파일러에게 말해줘야 함
  - 그래야 컴파일러가 구멍을 비워 놓음
  - 마치 함수 전방선언이 그랬던 것처럼

##### extern 키워드

- 다른 파일에 있는 전역 변수에 접근하려면 extern 키워드를 사용
- 어찌보면 C#의 public접근 제어자라고 생각할 수도 있지만
  - extern은 그걸 가져다 쓰려는 사람이 맘대로 쓸 수도 있음
  - (C는 접근 제어자가 없음)

```c
/* monster_repo.h */

extern int g_mob_count;
void add_monster(void);
```

```c
/* monster_repo.c */
#include "monster_repo.h"

int g_mob_count = 0;

void add_monster(void)
{
    ++g_mob_count;
}
```

```c
/* main.c */
#include <stdio.h>
#include "monster_repo.h"

/* 혹은, main.c에 둬도 됨 */
/* extern int g_mob_count; */

int main(void)
{
    add_monster();
    printf("# monsters: %d\n", g_mob_count);

    return 0;
}
```

- 헤더파일에 extern키워드를 써서 선언해줌  
  `extern int g_mob_count;`
- main.c파일에서 `#include "monster_repo.h"`하는 순간 복붙이 됨
- 실행하면 아무 오류 없이 실행된다.

##### extern 사용법

- 남의 라이브러리는 .c대신 라이브러리 바이너리 파일과 헤더만 줌
- 이런 경우 라이브러리 제작자가 extern을 아예 헤더에 포함시켜 줌
- 인클루드는 그냥 복붙이니 결과적으로 .c에 직접 넣는 것과 같음
- 여전히 c파일 안에 직접 extern을 넣는 경우가 많음
- 헤더에 넣는 것과 c파일에 넣는 것의 차이
  - 헤더에 넣는 것은 누구라도 쓸 수 있게 해주는 것
  - c파일에 넣는 것은 그 파일 안에서만 쓰려고 하는 것

```c
/* monster_repo.h */
int g_mob_count = 0;
void add_monster(void);
```

- 헤더파일에 이렇게 `int g_mob_count = 0;`처럼 extern키워드를 사용하지 않고 int를 입력해서 쓰면 링커 오류!
- g_mob_count가 monster_repo.c에 복붙 된 뒤 오브젝트 코드로 컴파일됨
- g_mob_count가 main.c에 복붙 된 두 오브젝트 코드로 컴파일됨
- 링크가 이 둘을 하빛려다가 중복된 전역 변수를 발견하고는 오류를 뱉는다

###### 그렇다면 함수는(?)

- 함수 프로토타입 **(=선언)**
  - 함수 앞에 extern을 붙일 수 있으나 그냥 선언을 하면 자동으로 extern
  - 굳이 extern 없어도 함수 뒤에 { 안 열고 그냥 ; 로 끝나니 쉽게 알 수 있음
  - 그래서 보통 extern 키워드 안 씀
- 함수 프로토타입 넣는 방법
  1. 사용할 곳에서 호출하기 전에 직접 원형을 넣음
  2. 헤더 파일에 넣어줌
- 함수의 경우 헤더 파일에 넣는 방법을 많이 씀

#### 전역 변수의 문제

- exturn 키워드를 사용하면 아무데서나 다 확인 가능하고
- 심지어는 지 맘대로 내 파일 안의 변수를 바꿔버림
- 파일이 무수히 많으면 어떤 코드가 전역 변수를 바꾸는지 알아채기 어려움
- 다른사람이 내 전역 변수를 못쓰게 하려면?
  - 즉, 내 파일 안에서만 쓰려면.
- 전역 변수 만들 때 static 키워드를 붙여주면 됨

#### static 키워드

- **다른 파일에서 전역 변수에 접근 못하게 막는 법**
- 이 변수의 범위가 파일로 한정됨
- 흔히 정적 변수라고 함
- 여전히 전역 변수로 프로그램 실행 동안에 실제 공간을 계속 차지하고 있음
- static 변수를 다른 파일에서 접근하려고 하면 링커 오류

##### static 키워드 예 - 정적변수를 다른 파일에서 사용하면

```c
/* monster_repo.h */
void add_monster(void);
```

```c
/* monster_repo.c */
#include "monster_repo.h"

static int s_mob_count = 0;

void add_monster(void)
{
    ++s_mob_count;
}
```

```c
/* main.c */
#include <stdio.h>
#include "monster_repo.h"

exturn int s_mob_count;

int main(void)
{
    add_monster();
    printf("# monsters: %d\n", s_mob_count);
    return 0;
}
```

- monster_repo.c파일에 정적으로 변수를 선언해 놓으면  
  `static int s_mob_count = 0;`
- main.c 파일에서 `exturn` 키워드를 써도 s_mob_count변수를 사용할 수 없음
- 컴파일을 해보면 컴파일은 되는데 링크가 안됨
  - 해당 변수를 찾을 수 없어서 링크가 안된다는 오류가 나옴
- static을 쓰면 해당 파일에서만 쓸 수 있도록 고정된다고 보면 됨

#### static의 또 다른 의미

- static이 없으면 지역변수
  - 함수 반환 시 그 변수도 사라짐
- static을 쓰면 개념상 전역 변수
  - 허나 그 함수 안에서만 접근 가능
  - 즉, 함수가 반환돼도 여전히 값은 저장되어있음

##### static 키워드 또 다른 예

```c
/* monster_repo.h */
void add_monster(void);
```

```c
/* monster_repo.c */
#include "monster_repo.h"

void add_monster(void)
{
    static int s_mob_count = 0;
    ++s_mob_count;
}
```

```c
/* main.c */
#include <stdio.h>
#include "monster_repo.h"

int main(void)
{
    add_monster(); /* s_mob_count -> 1 */
    add_monster(); /* s_mob_count -> 2 */
    add_monster(); /* s_mob_count -> 3 */
    return 0;
}
```

- `add_monster`함수안에 `static int s_mob_count = 0;`이 있음에도 `add_monster()`를 여러번 실행해보면 s_mob_count변수 값의 증가가 유지된다.
- `add_monster()`함수가 처음 실행될 때 0으로 초기화가 한 번만 실행되고 두번째부터는 더 이상 초기화 안하고 증가만시킴.
- 즉, static은 전역변수와 같은 개념을 갖지만 접근할 수 있는 곳은 함수 안이 전부다.

#### 함수와 static

- 역시 함수 앞에 static 키워드를 넣으면 외부로부터의 접근을 막을 수 있다.
- 특정 파일 안에서만 쓰려는 함수가 있다면 static키워드를 넣어주면 된다.

### .c와 .h파일 정리

- 빌드의 4단계가 올바로 돌게 하려면 아래의 기본원칙을 따라야 함

1. 헤더 파일에는 선언만 들어간다
    - 함수 선언
    - 전역 변수 extern 선언
2. .c파일에는 정의가 들어간다
    - 함수 정의
    - 전역 및 정적 변수 정의

### 순환 헤더 인클루드(circular header include)

- 헤더가 꼬였다는 얘기

```c
/* a.h 파일 */
#include "b.h"

/* 다른 코드들 */
```

```c
/* b.h 파일 */
#include "a.h"

/* 다른 코드들 */
```

```c
/* c.c 파일 */
#include "a.h"

/* 다른 코드들 */
```

- a.h파일을 포함한 b.h파일과 b.h파일을 포함한 a.h파일
- 서로를 포함하고있는데 a.h파일을 컴파일해보면..
  - a가 b를 복붙.. b가 다시 a를 복붙.....반복
- include가 너무 중첩이 됐다고 오류가 남
- 헤더 인클루드가 계속 순환한다고 해서 '순환 헤더 인클루드'라고 함

#### 해결법

##### 1.이런 상황을 최대한 피할 것

- `#include`는 가능하면 .c에서만 하기
- b헤더에서 a헤더를 인클루드 하는 대신 a에 정의된 것을 전방 선언하기
- 그러나 어쩔 수 없이 헤더 파일을 서로 인클루드해야 할 일이 있음
  - b.h에서 a.h에 정의된 '#define'이 필요할 경우

##### 2.인클루드 가드(guard)

- c에서 헤더 파일이 여러 번 인클루드 되는 걸 막는 업계 표준

```c
/* foo.h 파일 */
#ifndef FOO_H
#define FOO_H
/* 원래 헤더 파일 내용 */
#endif /* FOO_H */
```

###### 인클루드 가드 작동법

- 전처리기 지시문은 코드를 컴파일하기 전에 전처리기가 처리
- 이때
    1. 어떤 상수를 정의하고
    2. 컴파일러에게 **조건적으로 코드를 컴파일**하라고 지시
- 인간어로 예를들면,  
  
  ```c
  #ifndef FOO_H  /* 만약 FOO_H가 정의되지 않았다면 */
  #define FOO_H  /* FOO_H를 정의할 것 */
  /* 원래 헤더 파일 내용 */
  #endif /* FOO_H (#ifndef블록의 끝) */
  ```

###### 인클루드 가드를 이용해서 작성한 a.h와 b.h

```c
/* a.h 파일 */
#ifndef A_H
#define A_H
#include "b.h"

/* 다른 코드들 */

#endif /* A_H */
```

```c
/* b.h 파일 */
#ifndef B_H
#define B_H
#include "a.h"

/* 다른 코드들 */

#endif /* B_H */
```

```c
/* c.c 파일 */
#include "a.h"

/* 다른 코드들 */
```

- 이렇게 인클루드 가드를 이용해 작성하면 순환 헤더 인클루드를 방지할 수 있음
- c.c파일에서 (b.h파일을 include한)a.h 파일을 include해도
  - b.h파일의 _정의만 포함_ 하고 중첩된 `#include "a.h"`부분은 포함하지 않음.

-------

### C 컴파일러들

#### GCC

- C는 어느 한 회사가 주도하는 표준이 아니기에 컴파일러도 다양한 회사에서 나옴
- GCC (GNU 컴파일러 모음, GNU Compiler Collection)
  - 리눅스/유닉스 기반 플랫폼에서 주로 사용되던 컴파일러
  - 다양한 C표준을 대부분 제대로 지원

#### MS Visual C++

- 마이크로소프트 Visual C++
  - 원래 비주얼 스튜디오에 딸려오는 C++ 컴파일러이나 확장자가 .c일 경우 C로 컴파일
  - C99 표준
    - 그러나 모든 표준을 지키지는 않음
  - C11의 대부분을 지원하지 않음
  - 윈도우 기반 플랫폼에서 이것을 주로 사용

#### Clang과 그 외

- Clang
  - LLVM 컴파일러 구조를 사용하는 C계열 언어 컴파일러 프론트엔드
  - 원래 애플 사가 개발했음
    - 2007년에 오픈소스로 된 뒤 마이크로소프트, 구글 등 다양한 대기업들이 개발에 참여
  - gcc 컴파일러 대신 Clang을 쓰면 코드 변경 거의 없이 그대로 컴파일되고 빠른 컴파일 속도와 LLVM 구조가 제공하는 유용한 기능 덕에 많은 gcc 사용자들이 Clang으로 이주 중
  - clang-ci라는 비주얼 c와 호환되는 프론트엔드도 제공
- 기타 소형기기 전용 컴파일러도 많이 있음
# C언어의 기본 문법3_소스코드에서 실행파일까지

## C프로그램의 빌드 과정

- 빌드(build)란 무엇인가?
  - 사람이 읽기 쉬운 소스코드를 기계어 명령어로 변환하는 과정
  - 그리고 그 명령어들을 모아 기계에서 실행 가능한 실행파일로 만드는 과정
- C의 빌드는 4단계로 나뉘어져 있음
  1. 전처리(preprocessing)
  2. 컴파일(compilation)
  3. 어셈블(assembling)
    (1~3번을 합쳐 '컴파일'이라 하기도 함)
  4. 링크(linking)

`> clang -std=c89 -W -Wall -pedantic-errors *.c`

- 보통 커맨드라인에서 이렇게 빌드를 함
- 그러면 clang이 알아서 모든 4단계를 실행해 줌
  - 결과는 최종 실행파일(.exe, .out)
  - clang에서 한 단계씩 실행도 가능하다

### 소스코드의 구성

- C# - `adder.cs` `main.cs`
- C - `main.c` `adder.h` `adder.c`
  - adder파일이 h와 c로 나눠져 있다!
  - C는 고대언어이기 때문에 헤더파일과 c를 나눠놨다.

#### 두 종류의 소스코드 파일(.h와 .c)

##### C파일(.c)

- (우리가 생각하는 일반적인 소스코드 파일)
- 실제 프로그램을 돌게 하는 로직 코드를 저쟁해 두는 파일
- 내용물
  - 함수 정의(= 함수구현)
  - 전역 변수 등
  - 매크로

##### 헤더 파일(.h)

- 여러 소스코드 파일에 ((공유하고 싶은 코드를)공통적으로 필요한 것들을 저장해 두는 파일
- 내용물
  - 함수 선언
  - 매크로
  - extern 변수 선언 등
- **#include**로 포함함
  (예: `#include "adder.h"`)
- 사실 모든 소스코드를 .c파일 하나에 집어넣을 수도 있음
  - 그러나 코드가 100만줄이라면 난장판이 됨
- 문명인은 난장판 보다 적당히 정돈된 것을 좋아한다
  - 따라서 연관된 기능끼리 모아서 .c파일 하나씩 저장
  - 그러다 보면 논리적으로 분리된 여러 .c파일이 생김
- 이때 동이한 함수를 여러 곳에서 써야 한다면 복붙을 해야 할까?
  - NO! 코드중복!
  - 유지보수 잘 안됨
- 헤더 파일을 사용하면 함수 선언을 여러 C파일들과 공유 가능

##### 함수 선언만 가지고 어떻게 프로그램이 작동할까

- 빌드가 여러 단계로 쪼개져 있는 이유가 바로 정의 없이 선언만 가지고도 컴파일이 되게 하기 위해서 임
- 그리고 실제 올바른 기능 호출은 링크 단계가 책임짐

##### .c와 .h 파일 사용예: main과 adder

```c
/* adder.h */
int add(const int a, const int b);
```

```c
/* adder.c */
#include "adder.h"

int add(const int a, const int b)
{
    return a + b;
}
```

```c
/* main.c */
#include "adder.h"

int main(void)
{
    const int res = add(1,2);
    return 0;
}
```

- main함수에서 add함수를 호출하려면 add() 함수의 원형(함수의 선언)을 알아야 함
- adder.h에 add()의 원형을 저장
- add()의 최종 기능은 adder.c에 저장
  - 이렇게 하면 혹시 함수 기능을 수정해야 할 때도 원형은(헤더파일에) 그대로 유지
- main.c에서 `#include "adder.h"`만 하면 충분

#### #include < > vs #include "  "

- 인클루드 하는 법은 두 가지가 있음
- 이 둘의 차이는 디스크 상의 어디에서 헤더 파일을 찾느냐 차이

##### #include < >

- < >는 시스템 경로에서만 헤더 파일을 검색
  - 보통 컴파일러가 제공하는 시스템 헤더 파일을 인클루드할 때 사용(c에서 자체적으로 제공하는 기본 라이브러리 사용할 때)
  `#include <stdio.h>`

##### #include " "

- ""는 현재 작업 중인 디렉터리(working directory)에서 파일을 먼저 검색한 뒤 없으면 시스템 경로를 검색
  - 개발자가 구현한 헤더 파일들을 인클루드할 때 사용
  `#include "adder.h"`

## 빌드과정

### 전처리 단계

`소스코드(.h,.c) -> [ 전처리기 ] -> 확장된 소스 코드(트랜스레이션 유닛)`

- 보통 전처리기(preprocessor)라는 별도의 프로그램이 담당

1. **입력**

    - 입력: c파일 하나를 입력
2. **처리 과정1**

    - 주석 제거
3. **처리 과정2**

    - 매크로를 복붙 확장함
4. **처리 과정3**

    - 인클루드 파일들을 복붙 확장함
    - #include "헤더 파일"을 지우고 그 자리에 헤더파일 속에 있는 내용을 복사해서 가져다 붙이는 것
5. **출력**

    - 출력: 확장된 소스코드
    - 컴파일의 기본 단위인 **트랜슬레이션 유닛(translation unit)**

#### 트랜슬레이션 유닛 보는 방법

- clang 컴파일 중에 -E 플래그를 넣으면 됨  
  `> clang -std=c89 -W -Wall -pedantic-errors -E adder.c`
- 결과는 화면에 출력
- 파일로 저장하려면 출력 리디렉션(output redirection)을 쓰면 됨
  `> clang -std=c89 -W -Wall -pedantic-errors -E adder.c > adder.pre`

### 컴파일 단계

`확장된 소스 코드(트랜스레이션 유닛) -> [ 컴파일러 ] -> 어셈블리 코드`

- 컴파일러(compiler)라는 프로그램이 담당

1. **입력**

    - 입력: 트랜슬레이션 유닛
2. **출력**

    - 출력: 어셈블리어 코드
    - 어셈블리어는 기계 코드와 거의 1:1로 대응(하드웨어에 아주 가까움)
    - 그러나 텍스트 파일이어서 사람이 여전히 읽을 수 있는 언어
    - 기계가 이해하는 언어는 아님
    - 어셈블리어 코드는 아직 정의를 모르는 심볼을 사용할 수 있음
      - 심볼(symbol): 함수나 변수의 이름 등
      - 이것이 바로 헤더를 통한 선언만으로 컴파일이 가능한 이유!
    - 컴파일러가 어떤 함수나 변수의 정의를 못 찾을 경우
      - 선언만 보고 다음과 같이 행동함

      ```c
      컴파일러
      : 어? 이 함수랑 변수 정의가 없네?
        뭐, 어딘가에 있겠지?
        나중에 이 함수나 변수의 주소는 다른 누군가 채워 넣어 주겠지?
        일단 구멍으로 남겨놔야겠다.
      ```

    - 그 구멍을 채우는 건 링크 단계가 해 줌!

#### 어셈블리어 코드 보는 방법

- 컴파일 플래그 -S를 쓰면 어셈플리어 코드가 .s파일로 저장됨  
  `> clang -std=c89 -W -Wall -pedantic-errors -S adder.c`

#### 어셈블리어 코드가 나왔다는 의미는

- 이 단계 이후부터 코드는 특정 플랫폼에서만 동작한다는 이야기
  - 어셈블리어로 컴파일이 되는 순간 특정 기계에서만 동작
- C가 크로스 플랫폼이라는 주장은 컴파일되기 전까지만 임!
  - 소스코드일때는 윈도우, 맥, 리눅스 등등 다 돔
- 또한 타겟 플랫폼이 몊 비트냐에 따라 C의 자료형 크기가 달라질 수 있음
  - 어셈블리어 코드는 이미 그 자료형 크기가 결정된 후임

### 어셈블 단계

`어셈블리 코드 -> [어셈블러] -> 오브젝트 코드`

- 어셈블러(assembler)라는 프로그램이 담당

1. **입력**

    - 입력: 어셈블리어 코드
2. **출력**

    - 출력: 오브젝트 코드(object code)
    - 오브젝트 코드란?
      - 기계가 곧바로 이해 가능한 기계코드(machine code)
      - 기계어(machine instruction)라고도 한다
      - 즉, 이진코드
      - 어셈블리어 코드와 마찬가지로 여전히 메꿔야 하는 구멍이 있음

#### 오브젝트 코드 보는 방법

- -c 플래그를 넣어서 컴파일하면 .o파일로 저장됨  
  `> clang -std=c89 -W -Wall -pedantic-errors -c main.c`
- 이 파일은 일반 텍스트 편집기에서 보면 제대로 보이지 않음
  - 이진 파일이기 때문!
  - 16진수 편집기로 봐야 함.

### 링크 단계

`오브젝트 코드 -> [ 링커 ] -> 머신 코드 실행파일(.exe,.out)`

- 링커(linker)라는 프로그램이 담당

1. **입력**

    - 입력: 모든 오브젝트 코드들
2. **처리과정**

    - 링커는 모든 오브젝트 코드들을 모아다 구멍을 메꾼 뒤 실행파일로 저장
      - 링커가 오브젝트 파일을 다 모아서 하나의 이진(binary)파일로 만들면서 각 함수의 위치를 기억하고 있다가
      - 함수를 호출하려는 코드를 만나면 실행위치에 기억해둔 함수의 위치(주소)로 점프하는 코드를 넣어줌
    - 만약 선언만 믿고 사용한 함수나 변수가 여전히 구멍으로 남아 있다면?  
    (즉, 다른 오브젝트 코드에서 정의를 못 찾았다면?)
      - 링커가 못 찾는다며 링커 오류를 뱉음
      - 그 함수나 변수가 없어 실행할 방법이 없기에 경고가 아니라 오류
      - 링커에러 나오는경우: 함수원형에서 만들어놓은 것과 똑같은 함수를 만들지 않은 것(뭔가 틀렸거나 c파일을 지웠거나..)
      - exe파일 나오지도 않음
3. **출력**

    - 출력: 최종 실행파일(.exe, .out)

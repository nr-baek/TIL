# 포인터

## 지역 변수의 주소 출력하기

```c
#include <stdio.h>

void print_address(void)
{
    int num = 10;
    printf("Address of num: %p\n", (void*)&num);
}

int main(void)
{
    print_address();
    return 0;
}
```

- 컴파일 하면  
`Address of num : 0x7ffee04c894c` 출력됨

### 주소연산자 &

- 비트 연산자 &가 아님
  - 비트 연산자는 피연산자가 두 개, 주소 연산자는 피연산자가 한 개  

  ```c
  const unsigned char result = num1 & num2; /* 비트 연산자 */
  printf("Address of num : %p\n", (void*)&num);  /* 주소 연산자 */
  ```

- num이란 변수가 있으면 &num은 그 변수가 위치한 메모리 주소
- 보통 주소를 보여줄 때는 16진수를 사용
  - 읽기 편하기 때문
  - 그래서 `printf()`에서 서식 문자 %p는 주소를 16진수로 보여줌
- 참고: 실행할 때마다 주소가 달라질 수 있음
  - 요즘 운영체제에서는 보안 강화를 위해 실행할 때마다 주소를 바꿔줌(ASLR)

#### 주소를 변수에 저장할 수 있을까

```c
void try_save_address(void)
{
        int num = 10;
        int num_address = &num;
}
```

- 위 코드처럼 변수 num의 주소(메모리 위치)를 int형 변수 num_address에 저장하려고 하면 컴파일 에러가 난다.
  - int형 변수에 들어있는 값이 주소인지 아닌지 판단하기 어렵기 때문인 듯
- 따라서 **주소를 저장하기 위한 특별한 변수**가 필요하다.
  - 그것이 바로 **포.인.터.** (포인터도 변수다)

### 포인터(pointer)

- 메모리 주소를 저장하기 위한 변수형
  - 위치를 가리키는 변수라 해서 '포인터'라고 함
- 변수인데 속에 담긴 내용은 메모리 주소
- 그 주소에 저장된 자료형은?
  - 사실 하드웨어는 신경 안 씀
    - 그 비트패턴을 char로 읽으면 char
    - int로 읽으면 int
    - float으로 읽으면 float이 됨
- 그러나 해당 주소에서부터 몇 바이트를 읽어야 하는지는 하드웨어에게 알려줄 필요가 있음
- 그래서 포인터 변수를 선언할 때는 '그 주소에 어떤 형의 데이터가 있는지' 명시하기 위해 포인터 앞에 자료형을 붙임
  - int 포인터, float 포인터, char 포인터

#### 포인터 변수를 선언하는 법

```c
void save_address(void)
{
    int num = 10;
    int* num_address = &num;
}
```

- 포인터 변수를 선언하려면 자료형 뒤에 별표(*)를 붙임  
  `int*` `char*` `float*`
- 코딩 표준: 자료형에 *을 붙인다.
- 보통 `num_address`를 int포인터라고 부름
- 근데 영어로는 int로의 포인터(pointer to an int)라고도 함
- 포인터 변수도 변수이기에 메모리 어딘가 저장되어 있음
- 마찬가지로 변수이기 때문에 값을 변경할 수도 있다.  
  
  ```c
  void change_pointer(void)
  {
      char ch1 = 'C';
      char ch2 = 'z';

      char* pointer = &ch1;
      printf("%p: %c\n", (void*)pointer, *pointer);

      pointer = &ch2;
      printf("%p: %c\n", (void*)pointer, *pointer);
  }
  ```

  - 출력해보면
    - `0x7ffee16cc94f: C` `0x7ffee16cc94e: Z` 변경된 값이 대입돼서 출력이 바뀐것을 볼 수 있음

#### 포인터와 함수 매개변수

- 포인터도 변수니까 당연히 변수 쓰는 곳에는 다 쓸 수 있음
- 따라서 매개변수도 가능

```c
void print_address(int* num)
{
    printf("address of num: %p\n", (void*)num);
}

/* 메인 함수 */
int score = 88;
print_address(&score);
```

- `print_address(&score);`와 같이 함수의 매개변수로 포인터를 넣을 수 있음

#### 주소에 저장된 값을 출력하기

```c
void print_value(void)
{
    int score = 100;
    int* pointer = &score;

    printf("score: %d\n", *pointer);
}

void print_argument(float* arg)
{
    printf("argument: %f\n", *arg);
}

int main(void)
{
    float pi;

    print_value();

    pi = 3.14f;
    print_argument(&pi);
}
```

- 실행하면 `score: 100`, `argument: 3.140000`와 같이 포인터 변수에 실제 저장된 값이 출력된다.

##### 역 참조 연산자 *

- 곱하기 연산자 아님
  - 곱하기 연산자는 피연산자 2개를, 역 참조 연산자는 피연산자 1개를 가짐

  ```c
  const int result = num1 * num2; /* 곱하기 연산자 */
  printf("num : %d\n", * num); /* 역참조 연산자 */
  ```

- 포인터가 저장하고 있는 메모리 위치로 가서 거기에 저장된 값에 접근(읽거나 씀)함  
  (포인터가 가리키는 값에 접근한다고도 말함)

##### 참조와 역 참조

###### 참조

- 포인터가 이미 하고 있는 일
- 어떤 변수의 값을 직접 가져다 쓰는 게 아니라 그게 어디 있다고 '참조'
- 즉, 값이 어디에 있는지 가리키고 있는 것

###### 역 참조

- 주소로 직접 가서 거기 저장되어 있는 값에 접근하는 것
- 참조(reference)의 반대라 역 참조(de-reference)

##### 포인터 변수 선언 vs 역 참조 vs 주소 연산자

- `int*` 포인터형 변수 선언
- `*pointer` 역 참조(포인터가 가리키는 값에 접근)
- `&score` 변수의 주소 가져오기

##### 실제 데이터에 간접적으로 접근

- 값에 직접 접근하는 게 아님
- **주소를 이용해 간접적(한 단계 거쳐서)으로 접근**
- 따라서 **간접(indirect) 연산자** 라고도 함
- 중요한 개념!
  - 원본에 접근 가능
  - 컴퓨터 구조에서 데이터를 오랫동안 메모리에 저장하는 방법

#### 역 참조를 통해 값을 변경

```c
void update_value(void)
{
    int score = 100;
    int* pointer = &score;

    printf("score: %d\n", *pointer);
    *pointer = 50;
    printf("updated score: %d\n", *pointer);
}

void update_argument(float* arg)
{
    printf("argument: %f\n", *arg);
    *arg = 93485.2f;
    printf("updated argument: %f\n", *arg);
}
```

-`*pointer = 50;`, `*arg = 93485.2f;`처럼 포인터에 직접 변경할 값을 대입

##### 역 참조로 값을 변경할 수 있음

```c
int score = 100;
score = 50;
```

```c
int score = 100;
int* pointer = &score;

*pointer = 50;
```

- 위의 두 코드는 결과적으로 같음

###### 포인터를 이용한 swap함수

```c
void swap(int* arg1, int* arg2)
{
    int tmp

    tmp = *arg1;
    *arg1 = *arg2;
    *arg2 = tmp;
}

/* 메인 함수 */
int num1 = 20;
int num2 = 10;
swap(num1&, num2&);
```

- num1과 num2의 실제 원본값이 변경됨

#### 포인터와 함수 반환값

- 당연히 포인터도 변수니까 함수 반환값으로 사용 가능  
  `int* do_somthing(const int op1, const int op2);`
- 다만, 포인터를 반환할 때 조심해야 할 것이 있음

##### 지역 변수의 주소를 반환: 매우 위험한 코드

```c
int* add(const int op1, const int op2)
{
    int result = op1 + op2;

    return &result;
}

int main(void)
{
    int* result;

    result = add(10, 20);

    return 0;
}
```

- `return &result;` 함수 실행 결과값을 저장한 주소를 반환
- 함수의 지역 변수는 **스택 메모리**에 저장!!
- 함수의 호출이 끝나면 지역 변수도 사라짐(함수의 스택프레임이 더이상 유효하지 않음)
  - 해당 주소에 값은 남아있겠지만(다른 값을 아직 덮어쓰지 않았으니) 매우 위험
  - 반환된 주소는 다른값으로 언제든 덮어질 수 있음
  - 절대 작성하면 안되는 코드임
- **dangling pointer(댕글링 포인터)**
  - 지역 변수가 사용한 '주소'자체가 사라지는 것은 아님
  - 따라서 그 주소를 반환한다고 컴파일 오류가 나진 않음
    - 컴파일러에 따라 경고는 줄 수 있음
  - 문제는 포인터가 **유효하지 않은**주소를 가리키는 것!!
    - 이 경우 예측하지 못한 결과가 발생할 수 있음
  - 이러한 포인터를 댕글링 포인터라고 함

###### 포인터를 반환해도 되는 경우

- 전역 변수
  - (전역 변수는 주소가 바뀌지 않음)
  - 함수 스택프레임에 들어가지 않기때문에 사라지지 않음
- 파일 속 static 전역 변수
- 함수 내 static 전역 변수
- 힙 메모리에 생성한 데이터

```c
int* spawn_monster(void)
{
    static int s_monster_count; = 0;

    /* 코드 생략 */
    ++s_monster_count;

    return &s_monster_count;
}

/* 다른 함수 */
int count_pointer;
count_pointer = spawn_monster();
```

###### 포인터를 반환해야 할 때

- 도우미 함수 안에 생성한 변수를 다른 함수에서 사용하고자 할 때
  - 단, 일반 지역 변수면 안 됨(함수 호출이 끝나면 스택에서 사라짐)
- 함수 안에서 대용량의 데이터를 생성하고 그걸 반환하고자 할 때
  - 이 경우에는 데이터를 스택 메모리가 아니라 힙 메모리라는 곳에 생성함

###### 포인터 변수가 가리키는 값이 없을 때

```c
void do_something()
{
    int number;
    int* num_ptr = &number;

    /* 코드 생략 */

    num_ptr = NULL;
}
```

- `num_ptr = NULL;` 이 포인터 변수는 아무것도 안가리킨다.
  - 즉, 주소가 없다.(유효한 메모리 주소를 가리키지 않음)


##### 널(NULL) 포인터

- 아무것도 가리키지 않는 포인터
- 값이 '0'인 정수 상수 표현식, 혹은 void*로 캐스팅된 표현식
- 전용 매크로가 있음  
  `#define NULL ((void*)0)`
  - 널 포인터를 표현할 때 이 매크로를 사용할 것
- 포인터 변수와 NULL은 비교(==,!=) 가능

    ```c
    int* ptr;

    if(ptr == NULL) {  /* 만약 이 ptr이 null 포인터면 */
    /* 코드 생략 */
    }

    if(ptr != NULL) {  /* 만약 이 ptr이 null 포인터가 아니라면 */
    /* 코드 생략 */
    }
    ```

- 코딩 표준: 매크로 NULL을 반드시 사용할 것
  - 0은 사용하지 않는다
  - `if(ptr == 0)` 이렇게 0을 쓸 수도 있지만 사용하지 말 것
    - 포인터인지 숫자인지 헷갈리고 읽기 어려움
  - `if(ptr == NULL)` 이렇게 NULL을 사용하기


# 포인터

## 지역 변수의 주소 출력하기

```c
#include <stdio.h>

void print_address(void)
{
    int num = 10;
    printf("Address of num: %p\n", (void*)&num);
}

int main(void)
{
    print_address();
    return 0;
}
```

- 컴파일 하면  
`Address of num : 0x7ffee04c894c` 출력됨

### 주소연산자 &

- 비트 연산자 &가 아님
  - 비트 연산자는 피연산자가 두 개, 주소 연산자는 피연산자가 한 개  

  ```c
  const unsigned char result = num1 & num2; /* 비트 연산자 */
  printf("Address of num : %p\n", (void*)&num);  /* 주소 연산자 */
  ```

- num이란 변수가 있으면 &num은 그 변수가 위치한 메모리 주소
- 보통 주소를 보여줄 때는 16진수를 사용
  - 읽기 편하기 때문
  - 그래서 `printf()`에서 서식 문자 %p는 주소를 16진수로 보여줌
- 참고: 실행할 때마다 주소가 달라질 수 있음
  - 요즘 운영체제에서는 보안 강화를 위해 실행할 때마다 주소를 바꿔줌(ASLR)

#### 주소를 변수에 저장할 수 있을까

```c
void try_save_address(void)
{
        int num = 10;
        int num_address = &num;
}
```

- 위 코드처럼 변수 num의 주소(메모리 위치)를 int형 변수 num_address에 저장하려고 하면 컴파일 에러가 난다.
  - int형 변수에 들어있는 값이 주소인지 아닌지 판단하기 어렵기 때문인 듯
- 따라서 **주소를 저장하기 위한 특별한 변수**가 필요하다.
  - 그것이 바로 **포.인.터.** (포인터도 변수다)

### 포인터(pointer)

- 메모리 주소를 저장하기 위한 변수형
  - 위치를 가리키는 변수라 해서 '포인터'라고 함
- 변수인데 속에 담긴 내용은 메모리 주소
- 그 주소에 저장된 자료형은?
  - 사실 하드웨어는 신경 안 씀
    - 그 비트패턴을 char로 읽으면 char
    - int로 읽으면 int
    - float으로 읽으면 float이 됨
- 그러나 해당 주소에서부터 몇 바이트를 읽어야 하는지는 하드웨어에게 알려줄 필요가 있음
- 그래서 포인터 변수를 선언할 때는 '그 주소에 어떤 형의 데이터가 있는지' 명시하기 위해 포인터 앞에 자료형을 붙임
  - int 포인터, float 포인터, char 포인터

#### 포인터 변수를 선언하는 법

```c
void save_address(void)
{
    int num = 10;
    int* num_address = &num;
}
```

- 포인터 변수를 선언하려면 자료형 뒤에 별표(*)를 붙임  
  `int*` `char*` `float*`
- 코딩 표준: 자료형에 *을 붙인다.
- 보통 `num_address`를 int포인터라고 부름
- 근데 영어로는 int로의 포인터(pointer to an int)라고도 함
- 포인터 변수도 변수이기에 메모리 어딘가 저장되어 있음
- 마찬가지로 변수이기 때문에 값을 변경할 수도 있다.  
  
  ```c
  void change_pointer(void)
  {
      char ch1 = 'C';
      char ch2 = 'z';

      char* pointer = &ch1;
      printf("%p: %c\n", (void*)pointer, *pointer);

      pointer = &ch2;
      printf("%p: %c\n", (void*)pointer, *pointer);
  }
  ```

  - 출력해보면
    - `0x7ffee16cc94f: C` `0x7ffee16cc94e: Z` 변경된 값이 대입돼서 출력이 바뀐것을 볼 수 있음

#### 포인터와 함수 매개변수

- 포인터도 변수니까 당연히 변수 쓰는 곳에는 다 쓸 수 있음
- 따라서 매개변수도 가능

```c
void print_address(int* num)
{
    printf("address of num: %p\n", (void*)num);
}

/* 메인 함수 */
int score = 88;
print_address(&score);
```

- `print_address(&score);`와 같이 함수의 매개변수로 포인터를 넣을 수 있음

#### 주소에 저장된 값을 출력하기

```c
void print_value(void)
{
    int score = 100;
    int* pointer = &score;

    printf("score: %d\n", *pointer);
}

void print_argument(float* arg)
{
    printf("argument: %f\n", *arg);
}

int main(void)
{
    float pi;

    print_value();

    pi = 3.14f;
    print_argument(&pi);
}
```

- 실행하면 `score: 100`, `argument: 3.140000`와 같이 포인터 변수에 실제 저장된 값이 출력된다.

##### 역 참조 연산자 *

- 곱하기 연산자 아님
  - 곱하기 연산자는 피연산자 2개를, 역 참조 연산자는 피연산자 1개를 가짐

  ```c
  const int result = num1 * num2; /* 곱하기 연산자 */
  printf("num : %d\n", * num); /* 역참조 연산자 */
  ```

- 포인터가 저장하고 있는 메모리 위치로 가서 거기에 저장된 값에 접근(읽거나 씀)함  
  (포인터가 가리키는 값에 접근한다고도 말함)

##### 참조와 역 참조

###### 참조

- 포인터가 이미 하고 있는 일
- 어떤 변수의 값을 직접 가져다 쓰는 게 아니라 그게 어디 있다고 '참조'
- 즉, 값이 어디에 있는지 가리키고 있는 것

###### 역 참조

- 주소로 직접 가서 거기 저장되어 있는 값에 접근하는 것
- 참조(reference)의 반대라 역 참조(de-reference)

##### 포인터 변수 선언 vs 역 참조 vs 주소 연산자

- `int*` 포인터형 변수 선언
- `*pointer` 역 참조(포인터가 가리키는 값에 접근)
- `&score` 변수의 주소 가져오기

##### 실제 데이터에 간접적으로 접근

- 값에 직접 접근하는 게 아님
- **주소를 이용해 간접적(한 단계 거쳐서)으로 접근**
- 따라서 **간접(indirect) 연산자** 라고도 함
- 중요한 개념!
  - 원본에 접근 가능
  - 컴퓨터 구조에서 데이터를 오랫동안 메모리에 저장하는 방법

#### 역 참조를 통해 값을 변경

```c
void update_value(void)
{
    int score = 100;
    int* pointer = &score;

    printf("score: %d\n", *pointer);
    *pointer = 50;
    printf("updated score: %d\n", *pointer);
}

void update_argument(float* arg)
{
    printf("argument: %f\n", *arg);
    *arg = 93485.2f;
    printf("updated argument: %f\n", *arg);
}
```

-`*pointer = 50;`, `*arg = 93485.2f;`처럼 포인터에 직접 변경할 값을 대입

##### 역 참조로 값을 변경할 수 있음

```c
int score = 100;
score = 50;
```

```c
int score = 100;
int* pointer = &score;

*pointer = 50;
```

- 위의 두 코드는 결과적으로 같음

###### 포인터를 이용한 swap함수

```c
void swap(int* arg1, int* arg2)
{
    int tmp

    tmp = *arg1;
    *arg1 = *arg2;
    *arg2 = tmp;
}

/* 메인 함수 */
int num1 = 20;
int num2 = 10;
swap(num1&, num2&);
```

- num1과 num2의 실제 원본값이 변경됨

#### 포인터와 함수 반환값

- 당연히 포인터도 변수니까 함수 반환값으로 사용 가능  
  `int* do_somthing(const int op1, const int op2);`
- 다만, 포인터를 반환할 때 조심해야 할 것이 있음

##### 지역 변수의 주소를 반환: 매우 위험한 코드

```c
int* add(const int op1, const int op2)
{
    int result = op1 + op2;

    return &result;
}

int main(void)
{
    int* result;

    result = add(10, 20);

    return 0;
}
```

- `return &result;` 함수 실행 결과값을 저장한 주소를 반환
- 함수의 지역 변수는 **스택 메모리**에 저장!!
- 함수의 호출이 끝나면 지역 변수도 사라짐(함수의 스택프레임이 더이상 유효하지 않음)
  - 해당 주소에 값은 남아있겠지만(다른 값을 아직 덮어쓰지 않았으니) 매우 위험
  - 반환된 주소는 다른값으로 언제든 덮어질 수 있음
  - 절대 작성하면 안되는 코드임
- **dangling pointer(댕글링 포인터)**
  - 지역 변수가 사용한 '주소'자체가 사라지는 것은 아님
  - 따라서 그 주소를 반환한다고 컴파일 오류가 나진 않음
    - 컴파일러에 따라 경고는 줄 수 있음
  - 문제는 포인터가 **유효하지 않은**주소를 가리키는 것!!
    - 이 경우 예측하지 못한 결과가 발생할 수 있음
  - 이러한 포인터를 댕글링 포인터라고 함

###### 포인터를 반환해도 되는 경우

- 전역 변수
  - (전역 변수는 주소가 바뀌지 않음)
  - 함수 스택프레임에 들어가지 않기때문에 사라지지 않음
- 파일 속 static 전역 변수
- 함수 내 static 전역 변수
- 힙 메모리에 생성한 데이터

```c
int* spawn_monster(void)
{
    static int s_monster_count; = 0;

    /* 코드 생략 */
    ++s_monster_count;

    return &s_monster_count;
}

/* 다른 함수 */
int count_pointer;
count_pointer = spawn_monster();
```

###### 포인터를 반환해야 할 때

- 도우미 함수 안에 생성한 변수를 다른 함수에서 사용하고자 할 때
  - 단, 일반 지역 변수면 안 됨(함수 호출이 끝나면 스택에서 사라짐)
- 함수 안에서 대용량의 데이터를 생성하고 그걸 반환하고자 할 때
  - 이 경우에는 데이터를 스택 메모리가 아니라 힙 메모리라는 곳에 생성함

###### 포인터 변수가 가리키는 값이 없을 때

```c
void do_something()
{
    int number;
    int* num_ptr = &number;

    /* 코드 생략 */

    num_ptr = NULL;
}
```

- `num_ptr = NULL;` 이 포인터 변수는 아무것도 안가리킨다.
  - 즉, 주소가 없다.(유효한 메모리 주소를 가리키지 않음)

##### 널(NULL) 포인터

- 아무것도 가리키지 않는 포인터
- 값이 '0'인 정수 상수 표현식, 혹은 void*로 캐스팅된 표현식
- 전용 매크로가 있음  
  `#define NULL ((void*)0)`
  - 널 포인터를 표현할 때 이 매크로를 사용할 것
- 포인터 변수와 NULL은 비교(==,!=) 가능

    ```c
    int* ptr;

    if(ptr == NULL) {  /* 만약 이 ptr이 null 포인터면 */
    /* 코드 생략 */
    }

    if(ptr != NULL) {  /* 만약 이 ptr이 null 포인터가 아니라면 */
    /* 코드 생략 */
    }
    ```

- 코딩 표준: 매크로 NULL을 반드시 사용할 것
  - 0은 사용하지 않는다
  - `if(ptr == 0)` 이렇게 0을 쓸 수도 있지만 사용하지 말 것
    - 포인터인지 숫자인지 헷갈리고 읽기 어려움
  - `if(ptr == NULL)` 이렇게 NULL을 사용하기

##### NULL은 골칫덩어리다: 매개변수

- 함수 매개변수로 포인터가 들어올 때는 언제나 골칫덩어리
- 누구나 NULL을 넣을 수 있기 때문에
- 함수의 선조건(precondition) 문제
- 기본적으로 NULL이 안들어온다고 가정하고 함수를 작성할 것
- NULL이 들어올 수 있는 함수는 매개변수명에서 분명히 밝힐 것
- 코딩 표준: 널 포인터를 허용하는 매개변수
  - 함수의 매개변수가 널 포인터를 허용한다면, 매개변수 이름 끝에 '_or_null'을 붙인다

  ```c
  int get_score(const char* const student_id_or_null)
  {
      /* 코드 생략 */
  }
  ```

- NULL이 안들어온다고 가정한 경우 assert( )를 사용해 검증

  ```c
  #include <assert.h>
  #define PRICE (2)

  void increase_price(int* current_price)
  {
      assert(current_price != NULL);

      *current_price += PRICE;
  }
  ```

##### NULL은 골칫덩어리다: 반환값

- NULL을 반환할 때도 마찬가지
- 기본적으로 null 반환안함
- 반환을 해야 한다면 함수 이름에 NULL을 반환하는 것을 명시할 것
- 코딩 표준: 널 포인터를 반환하는 함수명
  - 함수가 널 포인터를 반화할 수 있다면, 함수 이름 끝에 '_or_null'을 붙인다

  ```c
  const char* get_name_or_null(const int id)
  {
      /* 코드 생략 */
  }
  ```

##### 널 포인터의 사용

1. 포인터 변수를 초기화하고 싶을 때
    - 아직 참조할 주소가 없을 때

    ```c
    void do_something(void)
    {
        int* ptr = NULL; /* 당장 사용하지 않으므로 널 포인터로 초기화 */

        /* 코드 생략 */
        ptr = &g_monster_count; /* 전역 변수의 주소 저장 */
        /* 코드 생략 */
    }
    ```

2. 포인터 변수가 유효한 주소를 참조하고 있는지 확인하고 싶을 때
    - 아무것도 가리키지 않는 포인터 변수를 역 참조하면?
        - 결과가 정의되지 않음(undefined behavior)
    - 역 참조를 하기 전에 널 포인터인지 확인할 것

        ```c
        void do_something(void)
        {
            /* 다른 변수 생략 */
            int* ptr = &num;

            /* 코드 100줄 */
            ptr = NULL;

            /* 코드 100줄 */
            if (ptr != NULL)
            {
                *ptr = 100;
            }
        }
        ```

3. 댕글링 포인터를 막기 위해
    - 동적 메모리 할당된 메모리를 더 이상 필요 없어서 해제했는데, 이를 여전히 가리키는 포인터가 있다면?
    - 더 이상 사용할수 없는 데이터니,  
    포인터 변수에 저장되어 있는 그 주소를 초기화해야 함
    - 이 때 널 포인터를 이용해 리셋

    ```c
    /* 동적 메모리 할당 */
    int* ptr = (int*)malloc(sizeof(int));

    /* 코드 100줄 */

    /* 더 이상 ptr을 사용하지 않음 */
    free(ptr);
    ptr = NULL;
    ```

#### 포인터의 비교

- 주소를 비교하는 코드

    ```c
    void do_something(int* num1, int* num2)
    {
        if (num1 == num2) /* 주소 비교 */
        {
            /* 코드 생략 */
        }
    }
    ```

- 값을 비교하는 코드

    ```c
    void do_something(int* num1, int* num2)
    {
        if (*num1 == *num2) /* 값 비교 */
        {
            /* 코드 생략 */
        }
    }
    ```

- 포인터는 비교 연산자를 이용해서 서로를 비교할 수 있음
  - ==, >, <, <=, >=, !=
- NULL 외의 주소를 비교하는 이유
  - 큰 메모리 통째를 잡아두고 그 안에 복수의 데이터를 넣어 사용할 때 필요

##### 포인터의 크기

- 모든 포인터는 동일한 크기를 가짐
- 포인터 크기는 코드를 컴파일하는 시스템 아키텍쳐에 따라 결정
  - 보통 CPU가 한 번에 처리할 수 있는 데이터의 크기(=워드, word)와 동일함
  - 예: 32비트 아키텍쳐에서 포인트 크기는 4바이트, 64비트 아키텍쳐에서 포인트 크기는 8바이트

```c
void print_pointer_size()
{
    char ch = 'C';
    int number = 934563;
    float pi = 3.1415f;

    char* char_ptr = &ch;
    int* int_ptr = &number;
    float* float_ptr = &pi;

    printf("char size: %d, char* size: %d\n", sizeof(*char_ptr), sizeof(char_ptr));
    printf("int size: %d, int* size: %d\n", sizeof(*int_ptr), sizeof(int_ptr));
    printf("float size: %d, float* size: %d\n", sizeof(*float_ptr), sizeof(float_ptr));

    /*  <출력>
        char size: 1, char* size: 4
        int size: 4, int* size: 4
        float size: 4, float* size: 4
    */
}
```

##### 배열을 포인터에 대입하기

```c
int nums[6] = { 0, 1, 2, 3, 4, 5 };
int* ptr = NULL;

ptr = nums; /* 컴파일 됨 */
ptr = nums[0]; /* 컴파일 오류 */
```

- `ptr = nums;` 은 배열의 주소를 포인터 변수에 대입한 것
- `ptr = nums[0];` 은 컴파일 오류가 남
  - nums[0]은 int지 int*가 아님
  - `ptr = &nums[0];` 이렇게 주소연산자를 붙여주면 컴파일이 된다.
- 포인터에 들어가는 값은 주소!!
  - C에서는 이 주소를 얻을 수 있는 방법은 딱 두가지 뿐임
  - 주소연산자(&), 배열의 이름
    - `float* p = &pi;` `int* p = days;`
    - 배열의 이름은 배열의 시작 주소를 알려줌
  
##### 배열 속에서 각 요소의 위치

- 배열에서 각 요소 사이의 바이트 간격은 일정
- 따라서, 첫 번째 요소의 주소와 자료형의 크기만 안다면 두 번째 요소의 주소를 알아낼 수 있음
  - 두 번째 요소 주소 = 첫 번째 요소 주소 + 자료형의 크기(바이트)
  - 세 번째 요소 주소 = 두 번째 요소 주소 + 자료형의 크기(바이트)
  - 반복..
- 포인터에 정수를 더하면 주소 이동
  - 포인터에 정수 n을 더하거나 빼면 언제나 "sizeof(자료형) x n"한 만큼 메모리 주소 이동

###### 배열 요소에 포인터로 접근하기 예

```c
int nums[3] = { 10, 20, 30 };
int* ptr = nums;

printf("%d, %d, %d\n", nums[1], ptr[1], *(ptr + 1));
```

- 20, 20, 20 출력 됨
- `ptr[1]` 배열의 첨자 연산자([ ])도 포인터에 쓸 수 있음
- nums[1], ptr[1], *(ptr + 1)
  - 모두 컴파일러에게 똑같은 의미
- 포인터 산술 연산에도 배열 첨자 연산자에도 동일하게 적용됨

##### 딱 '한' 바이트만 옮기고 싶다면?

- 한 바이트짜리 포인터로 캐스팅  
  `int_ptr = (char*)int_ptr + 1;`
- int* -> char* 캐스팅은 그 메모리 주소에 어떤 형이 들어있는지 알려주는 것을 캐스팅하는 거임

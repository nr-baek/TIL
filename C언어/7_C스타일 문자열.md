# C 스타일 문자열

## 문자열의 표현과 길이

- '문자열'과 '다른 기본 자료형'의 차이
  - 기본 자료형의 크기와 범위는 언제나 고정!
  - 문자열의 길이는 정해져 있지 않음
    - 따라서 하드웨어에게 문자열을 읽으라고 하면 어쩔 줄 모름
    - 이게 문자열이 기본 자료형이 아닌 이유!
- 문자열을 어떻게 표현할까?
  - 문자열은 여러 가지 글자(문자)가 모인 것!(공백조차 글자)
  - '여러개'의 문자를 표현하려면? -> 배.열.
  - 따라서 `char str[글자수]`라고 표현할 수 있음
- C 에서는 배열의 길이가 배열과 같이 저장이 안 됨
  - 따라서 프로그래머가 그 길이를 따로 기억해 둬야 함

### 문자열 관리 시 길이의 문제

- 길이를 저장하는 변수를 만들어두면 작업하기 쉽겠지만 실수가 많아짐
- 문자열을 바꾸고 길이를 저장한 변수값을 실수로 안바꾸면 문제가 생김
  - 혹은 길이를 잘못 세서 길이의 변수값을 잘못 넣을 수도 있음

#### 문자열 길이 문제 해결방법 1: 길이를 배열 첫 위치에 저장

- 첫 메모리 위치에 문자열 길이를 저장하고
- 실제 문자열이 뒤 따라오게 함
- unsigned char로 길이를 저장하기에 너무 짧음(최대 255글자)
  - 길이는 int로 저장하고 그 뒤에 char로 문자들을 저장
- 장점:첫 주소를 보는 것만으로도 총 글자 수가 몇인지 앎
  - 다른 언어에서 문자열의 크기를 바로 알 수 있던 이유
  - 이런 방식으로 문자열의 길이를 저장해 두기 때문
- 단점: 글자 하나가 1바이트인데 길이 저장하는데만 4바이트를 쓰기에는 용량낭비
  - 또한 순수 C코드로 이것을 작성하기에 애매함  

  ```c
  char array[9]; /* 길이 5와 문자열 "hello"가 적혀있음 */

  int* len = (int*)&array[0];
  char* str = &array[4];
  ```

#### 문자열 길이 문제 해결방법 2: 문자열이 끝나는 위치를 표시

- 그냥 char[]만 쓰되 그 문자열이 끝나는 위치에 **특수한 문자** 를 두자
- 배열에서 값을 찾을 수 없으면 존재할 수 없는 색인 -1을 반환하는 방식과 마찬가지

```c
size_t index_of(const char* str, char c)
{
    /* str 안에 c가 있으면 해당 색인 */
    /* 없으면 -1 */
}
```

- 아스키코드 중에 화면에 출력되지 않는 특수 문자들이 있음
  - 제어 문자(control character)라고 불림
  - 0 ~ 31,127
  - 그 중 하나가 바로 0 (널 문자, 널 캐릭터 라고 불림)
  - 널 포인터와는 다름!  
  `char null_char = '\0';`
    - 아스키코드로 '\0'은 0이니 0으로도 작성 가능
    - 그러나 읽기 쉽게 '\0'로 써주자
    |'H'|'e'|'l'|'l'|'o'|'\0'|
    |-|-|-|-|-|-|
- **C 스타일 문자열이라 하면 널 문자로 끝나는 char 배열을 말함**

## C 스타일 문자열이란

- char[]로만 구성
- 문자열이 끝나는 곳에 널 문자를 붙임

```c
char str1[] = "abc"; /* 스택에 "abc" 저장 */
char* str2 = "abc"; /* 데이터 섹션에 "abc" 저장 */
```

- 문자열 뒤에 별도로 '\0'를 넣지 않아도 컴파일러가 알아서 넣어줌
  - 둘 다 메모리를 확인해보면 'a''b''c''\0'으로 뒤에 널문자가 붙음
  - 이 두 코드는 저장 위치 외에는 동일

```c
const char str[] = "POCU";
printf("str length: %d\n", sizeof(str));
```

- `str length: 5` 출력
- 문자열의 길이는 4, 배열의 길이는 최소한 5(널문자 포함)
  - 언제나 배열에 널 문자도 있다는 걸 잊지 말자!
- 단, 이 경우에는 '\0'을 넣어주지 않음  
  `char str[] = { 'a', 'b', 'c' };`
  - '\0'으로 끝나지 않기 때문에 문자열관련 함수를 쓰면 문제가 생길 수 있음

### C 스타일 문자열의 장단점

- 장점
  - 가장 최소한의 메모리!
  - 한 가지 데이터형으로 문자열과 길이를 다 표현!
- 단점
  - 어떤 문자열의 길이를 알려면 배열을 끝까지 훑어야 함. O(N)

### 문자열 길이 구하기

1. char 배열의 요소를 처음부터 차례대로 읽는다
2. 널 문자를 만나면 멈춘다
3. 여태까지 총 몇 개의 char를 방문했는지 그 카운터를 반환

```c
size_t get_string_length(const char* str)
{
    size_t i;
    for(i = 0; str[i] != '\0'; ++i)
    {
    }

    return i;
}
```

### 좀 더 효율적인 문자열 길이 구하기

[코드 1]

```c
size_t get_string_length(const char* str)
{
    const char* p = str;

    while (*p++ != '\0') {
    }

    return p - str - 1;
}
```

[코드 2]

```c
size_t get_string_length(const char* str)
{
    size_t count = 0;
    const char* p = str;

    while (*p++ != '\0'){
        ++count;
    }

    return count;
}
```

- 사실 문자열 길이를 구하는 함수는 있음
- <string.h> 인클루드 하고 strlen 함수를 사용하면 됨
  - '\0'으로 끝나지 않는 배열에 적용하면 문제 발생함
  - 하드웨어가 보호하는 메모리를 읽는 경우 뻑남
  - 외부에서 들어오는 문자열 읽을 때 조심해서 읽어야 함

## 문자열 조작

### 두 문자열의 비교 compare_string()

`int compare_string(const char* str0, const char* str1);`

- 두 문자열을 비교할 거니까 매개변수는 두 문자열 포인터
- 단순히 같다/틀리다 보다는 '사전식 순서'로 어떤 문자의 아스키 코드가 더 작냐/같냐/크냐를 판별
  - 사전식 순서 예
  - ABCD 는 ABCE 보다 작음
    - A_65 B_66 C_67 D_68 < A_65 B_66 C_67 E_69
  - abcd 는 ABCD 보다 큼
    - a_97 b_98 c_99 d_100 > A_65 B_66 C_67 D_68
  - ABC 는 ABCDEFG 보다 작음
    - 길이가 짧음
- 반환형은 int
  - 같으면 0
  - 좌항이 작으면 < 0
  - 좌항이 크면 > 0

```c
const char* str1 = "AB";
const char* str2 = "AC";
int result = compare_string(str1, str2);
```

- 알고리듬 순서
    1. 두 문자열에서 문자를 하나씩(c0, c1) 읽음
    2. 두 문자를 비교
        a) c0이 c1보다 작으면 음수를 반환
        b) c0이 c1보다 크면 양수를 반환
        c) (c0과 c1이 같고) 널 문자면 0을 반환
    3. 다음 문자로 이동 후 1번 단계로 돌아감

### 효율적인 문자열 비교 함수 작성하기

[방법 1]

```c
int compare_string(const char* str0, const char* str1)
{
    while(*str0 != '\0' && *str0 == *str1)
    {
        ++str0;
        ++str1;
    }

    return *str0 - *str1;
}
```

[방법 2]

```c
int compare_string(const char* str0, const char* str1)
{
    while(*str0 != '\0' && *str0 == *str1)
    {
        ++str0;
        ++str1;
    }

    if (*str0 == *str1)
    {
        return 0;
    }

    return *str0 > *str1 ? 1 : -1;
}
```

- <strint.h>안에 문자열 비교하는 함수가 있음
  - strcmp() 함수를 쓰면 같은 기능

## 문자열 복사

```c
void copy_string(char* dest, const char* src)
{
    while(*src != '\0')
    {
        *dest++ *src++;
    }
    *dest = '\0';
}

/* 다른 함수 */
const char* str1 = "Pope";
char str2[5];

copy_string(str2,str1);
```

- 이 또한 함수가 <string.h>안에 있음
- `strcpy()`

# CLI에서 GIT 사용하기_생활코딩

생활코딩의 GITn강의를 들으며 정리한 내용들이다.
[생활코딩 GITn 강의듣기](https://opentutorials.org/course/3837)  
익숙하지 않은 cli환경에서 정말 자세하고 친절하게 설명해주셔서 어렵지 않게 명령어들을 배울 수 있었다.  
버전관리에 대한 이해와 git을 사용하는 방법에 대한 강의 내용이니 필요한 사람은 시간을 투자해서 강의를 들으면 도움이 될것이다!!

## 1. 버전 관리 시작 전 저장소(repository) 만들기

먼저 내가 버전 관리 용으로 쓰려는 디렉터리(일어나는 일들로 하여금 버전으로 관리되었으면 하는 디렉토리)로 이동을 한 후 `.git init`을 입력.

```c
 cd myProject주소
```

이동을 한 후 `.git init`을 입력.

```c
> .git init
```

`.git init`은 git에게 앞으로 이 디렉터리를 버전관리 시작하라는 명령어이다.  
`.git init` 명령을 하고나면 "Initialized empty Git repository in /Users/myCom/Desktop/myProject/.git/" 과 같이 현재 디렉터리 주소/.git/에 비어있는 git저장소가 초기화 되었다는 메세지가 뜬다.  

ls -a을 해보면 .git이라는 디렉터리가 생겨있는걸 확인 할 수 있다.  
이제 이 폴더는 버전관리가 이뤄지는 저장소가 된 것이다.  
.git이라는 디렉터리 안에는 버전에 관한 여러 정보들이 들어가는데, 때문에 사용자가 실수로 삭제하지 않게 하기 위해 숨겨진 폴더로 저장된다.

## 2. 버전 관리 영역의 용어

버전을 생성하기에 앞서 알아야 할 용어를 몇가지 살펴보자.

### Working tree

버전을 관리하려는, 버전으로 만들어지기 전 단계의 작업들. 즉, 버전관리가 되고 있는 파일의 수정사항이 올라오는 곳이다. (수정한 파일이 있는 곳)

### Staging area

버전으로 만들려는 파일들을 올려놓는 곳이다.  
하나의 버전으로 지정하기 전, 버전으로서 지정할 것들을 모아놓는 곳이라고 생각하면 된다.
예를들어, 수정 된 여러가지의 파일들 중 몇 가지 일부만 버전으로 하고싶을 때 버전으로 지정할 것들을 선택해서 staging area에 올린다.

### Repositiry

버전이 저장되어있는 .git 디렉터리 저장소 (만들어진 버전들이 있는 곳)

## 3. git 명령어

### git status

```c
> git status
```

현재 버전관리의 상태를 보여주는 메세지.  

- no commit yet : 커밋(버전으로 관리)할 파일이 아무것도 없음.
- untracked file - 파일명 : 추적되고 있지 않은 파일
- change to be committed - 파일명 : 해당 파일이 staging area로 올라가있음을 의미
- nothing to commit, working tree clean: 버전관리로 등록되지 않은 수정사항이 없음(수정한게 없거나/ 다 버전관리로 등록했거나)

### git add

파일의 수정사항을 staging area에 올리라는 명령어이다. (이 파일의 수정내역을 버전으로 만들겠다는 의미)

```c
> git add hello.txt
> git add .
```

`git add .`과 같이 파일명 대신 마침표(.)를 찍으면 현재 위치 아래의 수정된 모든 파일을 add한다.  
또한 파일명 대신 디렉터리명을 넣으면 해당 디렉터리 안의 수정된 모든 파일을 add한다.

### git commit

staging area에 올려진 버전들을 "커밋 메세지"와 함께 repository에 저장되어 버전으로 기록되게 하는 명령어이다.  
(버전에 관한 설명과 함께 버전으로 등록하는 명령어)

```c
> git commit -m "수정사항에 대한 내용"
```

git commit명령어를 -m 옵션 없이 입력하면 기본으로 설정되어있는 에디터가 나온다.  
에디터를 통해 커밋 메세지를 입력하면 여러줄을 입력하기 편하다.  
여러명이 협업하는 프로젝트는 커밋메세지가 중요하다고 한다.  
간결하지만 자세하게 작성해야하고 협업자가 보기에 어떤 수정사항이 있었는지 바로 알 수 있도록 작성하는것이 좋다고 한다.  
기본 에디터를 사용하기 편한 에디터로 바꿔주면 편리하다.  

#### 커밋 메세지 작성시 기본 에디터 설정하기

예를들어 nano 에디터를 기본 에디터로 설정

```c
>git config --global core.editor "nano"
```

#### 커밋 메세지 수정

만약 커밋 메세지를 잘못 입력했을 때

```c
> git commit --amend
```

위와같이 git commit에 `--amend`옵션을 입력하면 커밋메시지를 수정할 수 있는 에디터가 열리는데 거기서 수정해주면 된다.

#### add와 commit을 한번에 하기

```c
> git commit -am "수정사항에 대한 내용"
```

이것은 add와 commit을 한 번에 해주는 편리한 기능이다.  
그러나 새로 생성된 파일의 경우 자동으로 add가 되지 않기 때문에 주의해야 한다.  
(무조건 최소 한번의 add가 된 파일들만 add와 commit이 된다.)  
또한 add와 commit을 한 번에 하기보다는 add 후에 commit을 하는게 더 안전하다.  
(실수로 원치않던 파일도 버전에 포함될 수 있기 때문)

## 4. 버전간의 차이점 비교

```c
> git diff
```

버전관리의 마지막 버전과 working tree사이의 차이점을 보여줌.  
수정된 txt파일이 있다면 '-'로 삭제된 텍스트를, '+'로 추가된 텍스트를 표시함.  
**버전을 만들기 전 어떤 수정사항이 있었는지 검토할 수 있음.**  

### git log

파일의 버전 기록들을 볼 수 있음.

```c
> git log
> git log --oneline    // 버전의 기록을 한줄로 보여줌
> git log --stat  // 자세하게 커밋 메세지에 어떠한 파일이 연루되어있는지까지 보여줌
> git log -p  // 각 버전의 기록을 그 이전과 비교해서 쭉~ 보여줌.
```

`git log -p`명령은 복잡한 코드에서 문서상 문제가 생겼을 때 문제를 추적하는데 도움이 된다.  
즉, 버전과 버전간의 차이를 비교할 수 있다.  

## 5. Checkout과 시간여행

`git log`명령어를 실행하면 최근순으로 관리되고 있는 버전들이 나오는데,  
각 버전마다 'commit f5d714536.....5a3456a1af411' 처럼 알파벳과 숫자로 이루어진 알 수 없는 텍스트가 있다.  
해당 버전을 가리키는 주소라고 보면 되며 커밋 아이디라고 불린다.  
만약 만들던 작업물을 이전의 버전으로 되돌려 놓고 싶을 때, **checkout** 명령어를 쓰면 된다.  

```c
> git checkout f5d714536.....5a3456a1af411  // 해당 버전의 커밋아이디
```

checkout을 하면 그 버전 이후에 수정/추가 된 내용과 추가된 파일들 모두 없어지며 되돌아간 버전으로 작업물의 상태가 바뀐다.  
지금 작업하는 로컬브랜치를 가리키는 포인터인 **head**를 해당버전으로 옮긴 것이다.  

그러다가 다시 최근 버전으로 돌아가고 싶으면 git checkout master라고 입력한다.  (또는 master대신 최근 버전의 주소를 입력해준다.)  

이렇게 `git checkout 버전의 커밋 아이디`를 입력해주면 작업내용이 해당 버전의 상태로 바뀐다.  

## 6. 버전 삭제하기

```c
> git reset --hard
```

수정하기 이전 가장 마지막 버전관리의 상태로 돌아가며 작업(수정)한 내용이 사라진다.  

만약 버전1, 버전2, 버전3이 있을 때 버전 3을 지우고 버전2의 상태가 되고싶다면.  
'버전2로 reset' 하면 된다.  

```c
> git reset --hard 버전2의 주소
```

(주의!)  
"버전2로 리셋하겠다." === "작업상태가 버전2가 되도록 하겠다."  
_"버전2를 리셋하겠다"가 아님을 주의해야한다!_  

`--hard`를 입력하면 작업하고 돌아가기 전 최근의 버전에서 작업하던것을 날리고 버전2로 되돌아가겠다는 강력한 의미의 reset이 된다.  
이외에도 `--soft, --mixed` 옵션이 있다.

`-hard`, `--soft`, `--mixed`의 옵션으로 무엇으로 주느냐에 따라서 stage, working directory의 상태가 달라진다.

_(근데.. `git reset --hard`로 강력한(?) reset을 했는데 `git checkout`으로 최근 버전의 아이디를 명령하면 다시 최근버전으로 돌아온다..읭?.. 잘못 실습한걸까.. ㅠ  
후에 다시 살펴봐야겠다.. 아마 reset이후에 아무작업 없이 checkout을 해서 그런것일까?  
사실 굳이 working tree의 작업물까지 강력하게 지우면서 reset을 해야하는 상황이 어떤상황인지 이해가 잘 되지 않는다. 다시 이전버전부터 정갈하게 작업하고싶을 때 쓰는걸까..?  
그냥 checkout을 쓰면 되는것 아닌가 싶기도 하고 checkout이랑 reset이랑 뭐가다른지 아직 이해가 안가서 좀 더 알아봐야겠다. )_

>git reset : 브랜치가 가리키는 버전을 바꾼다.
>git checkout : HEAD가 가르키는 것(브랜치나 >버전)을 바꾼다.

## 7. 버전 되돌리기

### git revert

`git reset`과 비슷해서 헷갈릴 수 있음.(단어도 용도도 비슷하다)  

예를들어, `M1 - M2 - M3 - R3 - R4(head)` 순서의 버전이 있을 경우.  
최근 버전인 R4에서 R3로 되돌려 놓고 싶을 때 + 버전들의 기록은 남기고 싶을 때.  
이 때 `revert`를 써주면 된다.  
R3로 되돌려 놓으려면 **R4를 revert**한다. (R4의 커밋 아이디가 필요하다)  

```c
> git revert R4의 커밋 아이디
```

위의 명령어를 입력하면 기본 설정되어있는 에디터(나의 경우는 nano)가 뜨는데,  
위에 `revert "R4"`라고 자동으로 메세지가 입력되어 있는걸 확인 할 수 있다.  
내용을 추가하거나 내버려둬도 된다.  
에디터를 닫고 `git log`로 확인해보면 기존의 R4가 지워진 것이 아닌 이전의 R3버전의 상태와 같은  
새로운 버전이 만들어진 것을 확인할 수 있다.  
`M1 - M2 - M3 - R3 - R4 - R3(head)`버전으로 **R4의 버전은 살아있으면서 R3의 버전으로 되돌려진 상태가 된 것이다.**  

#### 훨씬 이전의 버전으로 revert할 때  

`M1 - M2 - M3 - R3 - R4(head)`상태인 현재 R4버전에서 M1으로 revert하고 싶다면?  
_곧바로 M2로 revert 하는것이 아닌_  

```c
> git revert R4
> git revert R3
> git revert M3
> git revert M2
```

이렇게 순서대로 한 버전씩 앞으로 revert를 각각 해줘야 한다.  
곧바로 revert M2를 해버리면 충돌이 일어난다. git은 M2이후의 모든 수정사항들을 revert해주는 것이 아닌 M2를 커밋할 당시의 수정사항만 revert하기 때문에 R4버전의 상태에서 바로 revert M2f를 적용하면 혼란이 온다. **반드시 revert는 역순으로 적용할 것!**  

## 8. 브랜치  

한 작업물에서 여러 결과물을 내는 등 한 작업을 이용하여 하나 이상의 다른 추가적인 작업을 할 때 유용하다.  

따로 브랜치를 만들지 않은 상황에서 `git branch`명령어를 입력해 보면 우선 master라는 브랜치만 나온다.  
master브랜치는 git저장소를 만든 순간에 작업하고 있던 최초의 브랜치라고 생각하면 된다.  

### 브랜치 만들기

apple이라는 이름의 브랜치를 새로 만들어 보자.

```c
> git branch apple
```

apple브랜치를 만든 후 `git branch`명령어로 확인해 보면 master와 apple브랜치가 나온다.  

```c
 apple
*master     // 앞에 별표가 붙은건 지금 master에 속해있는 상태라는 뜻
```

'git log'를 해보면 head가 마스터를 향하고 있고 옆에 apple브랜치가 추가되어있는걸 볼 수 있다.  
이어서 google과 ms라는 브랜치도 추가를 해본다.

```c
> git branch google
> git branch ms
```

다시 `git log`를 해보면 `* 42e50b9 (HEAD -> master, ms, google, apple) work3`과 같이_(참고// 나는 버전이 work3인 상태에서 브랜치를 생성 한 것 버전 메세지는 당연히 개인마다 다르다)_ 만들어 놓은 브랜치들이 모두 표시된다.  
master가 머물고 있는 work3상태의 버전에서 브랜치들을 만들었기 때문에 다함께 표시되는 것이다.  
이 때, 파일을 수정하고 새로운 버전을 만든 후 `git log`를 보면  

```c
* 4cc1252 (HEAD -> master) master work4
* 42e50b9 (ms, google, apple) work3
* d487176 work2
* f0807c0 work1
```

이렇게 master브랜치는 work4버전이 되었고 ms, google, apple은 work3버전에 남아있다.  
이 시점은 master브랜치에 있기 때문에 HEAD는 master를 향하고 작업상태는 work4버전이다.  

### 다른 branch에서 작업하기

apple브랜치가 위치한 버전의 상태로 돌아가려 한다면,

```c
> git checkout apple
```

`git checkout`명령어를 써서 되돌아 가면 된다.  
그럼 작업상태는 work3버전으로 돌아가고 head는 apple을 가리키게 된다.  

```c
* 4cc1252 (master) master work4
* 42e50b9 (HEAD -> apple, ms, google) work 3
* d487176 work2
* f0807c0 work1
```

이 상태에서 작업물을 수정하고 새로운 파일도 추가해본다.
(기존 작업물 work.txt를 수정하고 apple.txt파일도 추가했다)
두 파일을 add, commit을 해주면~!!!!!!

```c
* d749425 (HEAD -> apple) apple work4
| * 4cc1252 (master) master work4
|/  
* 42e50b9 (ms, google) work3
* d487176 work2
* f0807c0 work1
```

이렇게 가지가 생겼다!!!  
`git log --oneline --graph`와 같이 `--graph`속성을 추가하면 가지가 표시된다.  
head가 가리키는 apple브랜치, 그리고 master브랜치의 부모버전은 work3로 같지만 각각 다른 작업과 다른 버전을 갖는다.  

마찬가지로 google브랜치와 ms브랜치도 각각 checkout을 한 뒤 파일을 수정해본다.  

```c
* a24036c (HEAD -> ms) ms work4
| * 752cb11 (google) google work4
|/  
| * d749425 (apple) apple work4
|/  
| * 4cc1252 (master) master work4
|/  
* 42e50b9 work3
* d487176 work2
* f0807c0 work1
```

따라란~~~~!  
각 브랜치에서 수정을 하고 `git log --oneline --graph`를 입력해보면 이렇게 work3으로부터 뻗어나온 각 브랜치들을 볼 수 있다.  
이렇게 브랜치를 통해 각 브랜치에서 작업했던 상태로 순간이동 할 수 있고,  
하나의 저장소 안에서 공ㅇ통의 작업을 공유하면서도 각각의 작업을 갖고 있을 수 있는 혁명적인 기능을 사용할 수 있다.  
(무엇보다 각 브랜치로 체크아웃 하면 작업물의 상태가 브랜치에 맞게 휙휙 변하는게 정말 신기하다!!)  

## 9.백업  

먼저 지역 저장소와 원격 저장소에 대해 알아야 한다.  

### Local Repository(지역 저장소)

작업용 컴퓨터에 있는 저장소

### Remote Repository(원격 저장소)

지역 저장소에 있는 것을 업로드해서 지역 저장소와 똑같이 하는 컴퓨터(인터넷상)에 설치되어 있는 저장소

이 둘을 연결한 다음 작업컴에 작업이 끝나고 `push`라는 것을 하면 지역 저장소에 있는 소스코드, 문서 등의 버전이 그대로 원격 저장소에 업로드된다.
작업이 끝날 때마다 `push`,`push`,`push`하는 것을 통해서 백업을 달성한다.  
백업을 한다는 것은 복원을 할 수 있다는 것!!  
회사에서 작업한 것을 원격 저장소에 push하고 집에서 그대로 원격저장소로부터 clone해오면 회사컴과 집컴이 같은 작업물의상태가 된다.  
그리고 집에서 작업한 것을 원격 저장소에 다시 push하고 회사에서는 원격저장소로부터 그 수정사항을 다시 당겨온다.  
수정사항을 원격 저장소에 올리는것은 `push`,  
원격저장소로부터 수정사항을 내려받는 것은 `pull`.  
이렇게 백업을 통해서 작업의 이동성을 극대화할 수 있다.  
백업의 중심에는 **원격 저장소**가 있다.  
GIT Hosting 서비스로 쉽게 원격 저장소를 이용할 수 있다.  

### GIT HOSTING

GIT Hosting서비스 중 가장 유명하고 중요한 서비스는 **GitHub**이다.  
전세계 수 많은 오픈소스가 만들어지고있는 오픈소스의 성지이다.  
GitHub를 통해 버전을 백업할 것이다.  

### 원격 저장소와 연결

백업을 위해서는 먼저 지역 저장소와 원격 저장소를 연결해야 한다.
(Github회원가입과 Github의 repository가 필요하다)  

원격 저장소에 대한 명령은 `remote`.  
그리고 `add`명령어로 원격 저장소를 추가하면 된다.  

1. GitHub에 만든 저장소의 https의 주소를 복사한다(ssh말고!).

    - 통신 방법에 http와 ssh 방식이 있다.
    - http: 보안적으로는 부족하고 조금 불편하지만 배우지 않고 그냥 할 수 있다고 함.
    - ssh: 보안적으로는 강력하고 편리하지만 배워야될게 많고 혼란스러울 수 있다고 함.  
      (다음에 http와 ssh에 대해 자세히 알아봐야겠다.

2. 원격 저장소의 주소를 붙여넣어 `git remote add origin`명렁어 뒤에 붙여넣는다.

```c
git remote add origin https://github.com/nr-baek/my-repo.git
```

지역 저장소에 'https://github.com/nr-baek/my-repo.git' 주소를 갖은 origin이라는 별명의 원격 저장소를 연결시킨 것.  
(하나의 지역 저장소에 여러개의 원격 저장소를 연결 시킬수도 있다)  
원격 저장소에 다른 별명을 붙여줄 수도 있다. 명령어의 `origin`자리에 원하는 별명을 붙여주면 된다.  
그러나 보통 기본적인 원격 저장소에는 'origin'이라는 이름을 사용하는것이 관습이라고 한다.  
잘 연결 되었는지 확인하기 위해 `git remote`명령을 입력 해보면 origin(또는 내가 붙인 별명)이 출력된다.  
`-v`옵션을 주면 연결된 주소까지 다 나온다.  

### 원격 저장소에 push하기

원격 저장소에 업로드하기 위해서는 `git push`하면 된다.  
깔끔.  
간단.  

원격 저장소가 연결되어있기 때문에 그냥 `git push`명령으로 업로드가 시작된다.

```c
fatal: The current branch hear has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin hear
```

이런 메세지가 뜨는데 이 중에 `git push --set-upstream origin hear`만 복사해서 입력창에 붙여넣어 입력한다.  
_지역 저장소가 여러 원격 저장소와 연결할 수 있기 때문에 어떤 원격 저장소와 기본적으로 연결 시킬것인지를 세팅해 주는 것._ (여러 원격 저장소와 연결하지 않을거라면 생략해도 되는 것 같다.)  
하고나면 업로드가 진행되기 전 GitHub의 비밀번호를 물어본다.  
입력해주면 업로드를 진행한다.  
GitHub사이트의 내 저장소에 가보면 컴퓨터에서의 파일들이 그대로 업로드 되어있고,  
commit부분을 확인해 보면 버전들의 log를 확인할 수 있다!!
앞으로는 `파일수정 - 저장 - add - commit - push`를 통해 버전관리와 원격저장소로 백업을 하면 된다.  

## 10. 클론

지역 저장소1과 원격 저장소가 연결되어 있을 때. 또다른 컴퓨터인 지역 저장소2에서 작업을 진행하려면 지역 저장소1의 작업물과 버전을 그대로 복원 해놔야한다.  
지금까지 작업한 저장소1의 작업물을 저장소2에 복제해서 작업상태를 복원해놓는 방법을 알아본다.  
(init은 최초로 저장소를 생성하는 것. 여기서는 clone명령어를 써줘야 한다.)  

먼저, 작업물을 저장할 디렉터리 위치로 간다.  

```c
> git clone 원격 저장소 주소
```

위의 명령어를 입력하면 원격 저장소 이름의 디렉터리가 생성되고 내용물을 확인해 보면 원격 저장소의 내용과 버전이 그대로 복제되온 것을 볼 수 있다.  
위의 명령어 뒤에 한칸 띄고 `디렉터리 이름`을 입력하면 설정한 디렉터리 이름으로 디렉터리가 만들어진다.  
이제 작업한 것을 push하면 된다 ㅎㅎㅎㅎ (원격 저장소와는 origin으로 바로 연결되어있음)  

### 작업 전 반드시 pull

여러대의 컴을 원격 저장소에 연결 했거나 협업의 상황에서는 반드시 작업 전 `git pull`을 해서 원격 저장소에 올라가 있는 내용을 가져와야한다.  
(혹시나 수정사항이 있을 수 있기 때문. 내가 작업한 곳에 같은 위치의 수정이면 충돌이 발생한다.)  
`git pull`을 하면 그것만으로 지역 저장소의 작업물과 버전이 원격 저장소의 것으로 업데이트 된다.  

소스트리같은 GUI방식의 버전관리보다는 쉽지 않지만 CLI방식을 자주 쓰다보면 오히려 이게 더 편하다고 한다.  
나도! CLI방식이 익숙해질 수 있도록 많이 써봐야겠다!  
나도!! 마우스보다는 키보드가 편한 날이 오겠지ㅎㅎ!!

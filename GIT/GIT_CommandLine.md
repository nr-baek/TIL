# CLI에서 GIT 사용하기_생활코딩

## 1. 버전 관리 시작 전 저장소(repository) 만들기

먼저 내가 버전 관리 용으로 쓰려는 디렉터리(일어나는 일들로 하여금 버전으로 관리되었으면 하는 디렉토리)로 이동을 한 후 `.git init`을 입력.

```c
 cd myProject주소
```

이동을 한 후 `.git init`을 입력.

```c
> .git init
```

`.git init`은 git에게 앞으로 이 디렉터리를 버전관리 시작하라는 명령어이다.  
`.git init` 명령을 하고나면 "Initialized empty Git repository in /Users/myCom/Desktop/myProject/.git/" 과 같이 현재 디렉터리 주소/.git/에 비어있는 git저장소가 초기화 되었다는 메세지가 뜬다.  

ls -a을 해보면 .git이라는 디렉터리가 생겨있는걸 확인 할 수 있다.  
이제 이 폴더는 버전관리가 이뤄지는 저장소가 된 것이다.  
.git이라는 디렉터리 안에는 버전에 관한 여러 정보들이 들어가는데, 때문에 사용자가 실수로 삭제하지 않게 하기 위해 숨겨진 폴더로 저장된다.

## 2. 버전 관리 영역의 용어

버전을 생성하기에 앞서 알아야 할 용어를 몇가지 살펴보자.

### Working tree

버전을 관리하려는, 버전으로 만들어지기 전 단계의 작업들. 즉, 버전관리가 되고 있는 파일의 수정사항이 올라오는 곳이다. (수정한 파일이 있는 곳)

### Staging area

버전으로 만들려는 파일들을 올려놓는 곳이다.  
하나의 버전으로 지정하기 전, 버전으로서 지정할 것들을 모아놓는 곳이라고 생각하면 된다.
예를들어, 수정 된 여러가지의 파일들 중 몇 가지 일부만 버전으로 하고싶을 때 버전으로 지정할 것들을 선택해서 staging area에 올린다.

### Repositiry

버전이 저장되어있는 .git 디렉터리 저장소 (만들어진 버전들이 있는 곳)

## 3. git 명령어

### git status

```c
> git status
```

현재 버전관리의 상태를 보여주는 메세지.  

- no commit yet : 커밋(버전으로 관리)할 파일이 아무것도 없음.
- untracked file - 파일명 : 추적되고 있지 않은 파일
- change to be committed - 파일명 : 해당 파일이 staging area로 올라가있음을 의미
- nothing to commit, working tree clean: 버전관리로 등록되지 않은 수정사항이 없음(수정한게 없거나/ 다 버전관리로 등록했거나)

### git add

파일의 수정사항을 staging area에 올리라는 명령어이다. (이 파일의 수정내역을 버전으로 만들겠다는 의미)

```c
> git add hello.txt
> git add .
```

`git add .`과 같이 파일명 대신 마침표(.)를 찍으면 현재 위치 아래의 수정된 모든 파일을 add한다.  
또한 파일명 대신 디렉터리명을 넣으면 해당 디렉터리 안의 수정된 모든 파일을 add한다.

### git commit

staging area에 올려진 버전들을 "커밋 메세지"와 함께 repository에 저장되어 버전으로 기록되게 하는 명령어이다.  
(버전에 관한 설명과 함께 버전으로 등록하는 명령어)

```c
> git commit -m "수정사항에 대한 내용"
```

git commit명령어를 -m 옵션 없이 입력하면 기본으로 설정되어있는 에디터가 나온다.  
에디터를 통해 커밋 메세지를 입력하면 여러줄을 입력하기 편하다.  
여러명이 협업하는 프로젝트는 커밋메세지가 중요하다고 한다.  
간결하지만 자세하게 작성해야하고 협업자가 보기에 어떤 수정사항이 있었는지 바로 알 수 있도록 작성하는것이 좋다고 한다.  
기본 에디터를 사용하기 편한 에디터로 바꿔주면 편리하다.  

#### 커밋 메세지 작성시 기본 에디터 설정하기

예를들어 nano 에디터를 기본 에디터로 설정

```c
>git config --global core.editor "nano"
```

#### 커밋 메세지 수정

만약 커밋 메세지를 잘못 입력했을 때

```c
> git commit --amend
```

위와같이 git commit에 `--amend`옵션을 입력하면 커밋메시지를 수정할 수 있는 에디터가 열리는데 거기서 수정해주면 된다.

#### add와 commit을 한번에 하기

```c
> git commit -am "수정사항에 대한 내용"
```

이것은 add와 commit을 한 번에 해주는 편리한 기능이다.  
그러나 새로 생성된 파일의 경우 자동으로 add가 되지 않기 때문에 주의해야 한다.  
(무조건 최소 한번의 add가 된 파일들만 add와 commit이 된다.)  
또한 add와 commit을 한 번에 하기보다는 add 후에 commit을 하는게 더 안전하다.  
(실수로 원치않던 파일도 버전에 포함될 수 있기 때문)

## 4. 버전간의 차이점 비교

```c
> git diff
```

버전관리의 마지막 버전과 working tree사이의 차이점을 보여줌.  
수정된 txt파일이 있다면 '-'로 삭제된 텍스트를, '+'로 추가된 텍스트를 표시함.  
**버전을 만들기 전 어떤 수정사항이 있었는지 검토할 수 있음.**  

### git log

파일의 버전 기록들을 볼 수 있음.

```c
> git log
> git log --oneline    // 버전의 기록을 한줄로 보여줌
> git log --stat  // 자세하게 커밋 메세지에 어떠한 파일이 연루되어있는지까지 보여줌
> git log -p  // 각 버전의 기록을 그 이전과 비교해서 쭉~ 보여줌.
```

`git log -p`명령은 복잡한 코드에서 문서상 문제가 생겼을 때 문제를 추적하는데 도움이 된다.  
즉, 버전과 버전간의 차이를 비교할 수 있다.  

## 5. Checkout과 시간여행

`git log`명령어를 실행하면 최근순으로 관리되고 있는 버전들이 나오는데,  
각 버전마다 'commit f5d714536.....5a3456a1af411' 처럼 알파벳과 숫자로 이루어진 알 수 없는 텍스트가 있다.  
해당 버전을 가리키는 주소라고 보면 되며 커밋 아이디라고 불린다.  
만약 만들던 작업물을 이전의 버전으로 되돌려 놓고 싶을 때, **checkout** 명령어를 쓰면 된다.  

```c
> git checkout f5d714536.....5a3456a1af411  // 해당 버전의 커밋아이디
```

checkout을 하면 그 버전 이후에 수정/추가 된 내용과 추가된 파일들 모두 없어지며 되돌아간 버전으로 작업물의 상태가 바뀐다.  
지금 작업하는 로컬브랜치를 가리키는 포인터인 **head**를 해당버전으로 옮긴 것이다.  

그러다가 다시 최근 버전으로 돌아가고 싶으면 git checkout master라고 입력한다.  (또는 master대신 최근 버전의 주소를 입력해준다.)  

이렇게 `git checkout 버전의 커밋 아이디`를 입력해주면 작업내용이 해당 버전의 상태로 바뀐다.  

## 6. 버전 삭제하기

```c
> git reset --hard
```

수정하기 이전 가장 마지막 버전관리의 상태로 돌아가며 작업(수정)한 내용이 사라진다.  

만약 버전1, 버전2, 버전3이 있을 때 버전 3을 지우고 버전2의 상태가 되고싶다면.  
'버전2로 reset' 하면 된다.  

```c
> git reset --hard 버전2의 주소
```

(주의!)  
"버전2로 리셋하겠다." === "작업상태가 버전2가 되도록 하겠다."  
_"버전2를 리셋하겠다"가 아님을 주의해야한다!_  

`--hard`를 입력하면 작업하고 돌아가기 전 최근의 버전에서 작업하던것을 날리고 버전2로 되돌아가겠다는 강력한 의미의 reset이 된다.  
이외에도 `--soft, --mixed` 옵션이 있다.

`-hard`, `--soft`, `--mixed`의 옵션으로 무엇으로 주느냐에 따라서 stage, working directory의 상태가 달라진다.

_(근데.. `git reset --hard`로 강력한(?) reset을 했는데 `git checkout`으로 최근 버전의 아이디를 명령하면 다시 최근버전으로 돌아온다..읭?.. 잘못 실습한걸까.. ㅠ  
후에 다시 살펴봐야겠다.. 아마 reset이후에 아무작업 없이 checkout을 해서 그런것일까?  
사실 굳이 working tree의 작업물까지 강력하게 지우면서 reset을 해야하는 상황이 어떤상황인지 이해가 잘 되지 않는다. 다시 이전버전부터 정갈하게 작업하고싶을 때 쓰는걸까..?  
그냥 checkout을 쓰면 되는것 아닌가 싶기도 하고 checkout이랑 reset이랑 뭐가다른지 아직 이해가 안가서 좀 더 알아봐야겠다. )_

>git reset : 브랜치가 가리키는 버전을 바꾼다.
>git checkout : HEAD가 가르키는 것(브랜치나 >버전)을 바꾼다.

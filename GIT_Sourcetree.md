# GIT_Sourcetree_생활코딩

버전관리란?
버전 = _의미있는_ 변화들(기능의 개선, 버그수정, 고객의 요구에 맞게 수정)
버전관리 시스템 = 변화의 관리
	1) 원복의 편리
	2) 백업

#### Sourcetree 설치하기
1. 먼저 GIT을 설치한다.
	- git-scm.com에 접속해서 버전에 맞게 GIT을 설치한다.
2. 설치 후 terminal창을 열어서 ‘git’을 입력해보며 잘 설치 됐는지 확인한다.
3. Sourcetree를 다운로드받아 설치한다.
(Sourcetree -> GUI환경에서 버전관리를 할 수 있는 git 사용 도구)

#### 저장소 만들기(init)
Add Repository -> Create Local Repository -> 설정(name:저장소이름, path:저장경로, type:git)
- 북마크 창에 설정한 저장소의 항목이 떠있으면 더블클릭해서 실행한다.

#### 버전 만들기
1. 설정한 저장소에 작업할 파일(index.html)을 만든다.
2. 파일을 만들고 소스트리의 화면을 보면 index.html이 나타나있다. 
	- GIT은 설정한 저장소에 변화(추가, 수정, 삭제)가 발생시 바로 파악하여 표시한다.
3. index.html 파일을 체크하고 commit버튼을 눌러준다.
4. Commit message(ex. html파일 추가)를 입력해준 뒤 commit을 한다.

 파일을 commit한 뒤 파일의 내용을 수정하고 버전리스트 창을 보면  ‘uncommitted changes(커밋하지 않은 변화)’라고 표시된 항목이 추가된 것을 볼 수 있다.
다시, commit을 눌러 변경내용을 입력하고 commit해주면 변경 된 버전이 생성된다.
- 기록해둔 내용으로 버전의 수정사항을 파악할 수 있다.
- 각 버전을 클릭해 보면 이전 버전과의 차이(변경과정)을 확인해 볼 수 있다.
- 이전의 내용에 해당되는 것을 열람 할 수 있다.
- 각각의 버전은 프로젝트의 변화를 의미하며 버전관리로 프로젝트의 진행과정을 추적해 볼 수 있다.

새 파일을 생성했을 때 -> ? 아이콘_ 아직 GIT에 추적되기 전
파일을 저장 및 commit했을 때 ->[✏️] 아이콘_ GIT에 의해 추적되고 있음(commit으로 버전관리되어 repository에 보관)

하나의 버전은 하나의 파일의 변경사항만이 아니라 그 저장소의 모든파일의 변경사항을 포괄할 수 있다.
- commit할 파일을 체크할 때 하나만 체크하면 하나만 됨.
- 두 개 이상의 파일을 수정 후 수정한 파일을 모두 체크하여 commit하면 한 버전에 해당 파일들이 모두 들어와 있는 것을 확인할 수 있다.


*<b>용어정리</b>_파일수정 후 uncommitted changes를 클릭 했을 때.
- working copy: 수정된 내역들이 나타나는 곳(commit할 내역을 체크하는 곳)
- add: working copy에 나타난 항목을 체크하는 행위
- index(staging area): working copy에 있는 파일을 체크해서 add하게 되면 이동하는 공간(체크되어 온 이곳의 파일에 대해서만 저장소의 버전으로 저장된다)


#### 되돌리기
_과거의 특정 상태의 코드(버전)으로 돌아갈 수 있다._

 - <b>수정사항 취소하기_(commit하기 전 상태일 때)</b>
   파일수정 후 저장했는데 이전의 상태로 돌리고 싶을 때
	(1) Uncommitted changes를 클릭해서 그 잘못 저장한 파일을 선택한다.
	(2) Discard hunk 클릭.
		- confirm discard changes : ok
        
    _이렇게 하면 가장 최근에 commit한 버전의 파일의 상태로 되돌아간다.
   (=working copy에 있는 점세개 아이콘을 클릭한 후 discard file을 눌러줘도 된다)_

 * <b>Reset_(이미 commit한 버전을 취소하고 싶을 때)</b>
   아주 예전의 a버전으로 돌아가고 싶을 때(a버전 이후 일어난 commit들을 삭제하고 싶을 때)
	(1) a버전을 선택하고 ‘Reset master to this commit’을 선택한다.
	(2) Using mode를 hard-discard all working copy changes로 선택 후 OK
	 (mixed 모드는 현재 작업하고 있는 작업물은 최신상태를 유지하면서 선택한 버전까지의 내용이 삭제됨)
    
    _Reset은 리셋하려고 선택한 그 버전 이후의 버전을 다 지워버린다._

 - <b>Revert_(선택한 버전을 취소해서 그 버전 이전 상태로 되돌리고 싶을 때)</b>
  작업한 d버전의 commit을 취소하고 싶을 때(혹시 모르니 가급적 버전을 유지하는게 좋음_작업한 버전을 삭제하지 않으면서 이전 버전으로 돌아가는 방법)
	(1) 취소하고싶은 d버전을 선택해서 ‘Reverse commit’을 한다.
	- 커밋 리스트에 ‘Revert d버전..’ 이라는 메세지가 자동으로 들어가 있다.
	
    (2) 확인해보면 d버전에서의 변화가 취소되고 이전 버전으로 되돌아가 있는것을 확인할 수 있다.
_만약 더 이전의 버전으로 돌아가고 싶다면 여러개의 버전을 역순으로 차례차례 Revert 해야한다. (여러개의 버전을 건너뛰고 revert하면 충돌(conflict)이 발생한다._
```
<Reset vs Revert>
Reset : 버전을 제거하고 이전의 상태로 되돌림.
Revert : 버전을 제거하지 않고 새로운 커밋을 생성하여 이전의 상태로 되돌림.
```
#### 브랜치(Branch)
하나의 소스트리 안에서 안정적인 작업과 안정적이지 않은 작업을 동시에 진행할 때
안정적인 작업과 실험적인 작업을 각각의 폴더에서 작업하는 것과 같은 효과를 내면서 동시에, 실험적인 작업에서 수정한 내용과 안정적 작업을 간편하게 자동화해서 병합해준다.
각각의 브랜치는 마치 프로젝트 디렉토리를 카피한 것과 같은효과를 볼 수 있다.

<b>브랜치 만들기</b>
[Branch] - [New Branch] 를 클릭 후 이름(실험)을 지정해서 Create Branch.
브랜치를 만들면 브랜치목록에 기존의 master브랜치와 새로 만든 실험블랜치가 목록에 있는것을 확인할 수 있고, 버전리스트를 보면 브랜치를 만들 당시의 버전에 실험브랜치이름이 추가되어있는 것을 확인할 수 있다.
작업을해보면 브랜치를 생성한 버전부터 각각의 브랜치마다 그래프가 갈라진다.
master브랜치에서 작업을하면서 여러번 커밋을 했다가 실험브랜치를 선택해보면 실험브랜치를 설정했을 당시의 버전으로 작업파일의 코드가 변경된 것을 확인할 수 있다.
(서로 다른 디렉토리에서 각각의 다른 파일을 수정하는 것과 비슷한 느낌)

<b>브랜치 병합하기(merge)</b>
실험브랜치에서 변경점을 master브랜치로 병합 (실험->master)
1. 브랜치를 master에 선택해둔다.
2. 실험브랜치에서 마우스우클릭 -> [merge 실험 into master]선택
3. 버전리스트에 'merge branch실험'이라는 버전이 자동으로 추가되면서 그래프가 병합된다.(merge를 통해 GIT이 병합과 동시에 commit을 해준다.)

<b>브랜치간의 충돌해결</b>
브랜치를 나눠 작업하다가 같은부분을 수정해서 자동으로 병합되지 않을 때
'Merge Conflicts'라고 경고가 뜬다.
같은 위치를 수정하면 GIT은 어느브랜치의 내용을 적용할지 선택하지 못하기에 conflict를 내서 문제해결을 사람에게 위임한다.

```
<<<<<<< HEAD
        aaaaa내용         (master브랜치 작업내용)
===============         <-기준
        bbbbb내용         (실험브랜치 작업내용)
>>>>>>> 실험              
`````````````````
작업파일을 열어보면 같은곳에 a내용과 b내용이 있다고 표시가 되어있다.
원하는 내용으로 내용을 수정하고 저장하면 된다.
working copy에 보면 노란 경고판이 떠있는것을 확인 할 수 있다. 
[마우스우클릭] -> [Resolve Conflicts] -> [Mark resolved]를 선택해서 충돌이 해결됐음을 GIT에게 알려준다. 
충돌을 해결하고 commit을 하면 commit log가 저절로 기록되어있다.

<b>브랜치 충돌의 최소화</b>
실험브랜치의 변경내용이 길고 작업기간이 오래걸린다면...
master브랜치에서 실험브랜치를 한번에 병합하는 것이 아니라
_실험브랜치가 끊임없이 master브랜치의 내용을 동기화_ 해서 가져와야한다.
(실험브랜치는 언젠가 master브랜치에 병합 될 것을 염두하고 내용을 입력,수정 할때마다 실험브랜치에 master브랜치의 내용을 가져와서 동기화한다.)
나중에 병합했을 때 충돌을 최소화하기위해 꾸준히 master브랜치의 내용을 병합하면서 그때그때 충돌사항을 해결해놓는 것이다.
```
   master          실험브랜치
    작업     ->    흡수(동기화)
    작업     ->    흡수(동기화)
    작업     ->    흡수(동기화)
     최종병합(master <- 실험)
```

#### 원격저장소
로컬저장소와 원격저장소를 서로 연결 및 백업할 수 있다.
<b>원격저장소의 종류</b>
- 깃헙 : 가장 대표적인 원격저장소. 보편적으로 많이 사용한다.
- 깃랩 : 깃헙같은 서비스를 제공
- 요비 : 깃헙, 깃랩같은 협업 개발 플랫폼

<b>깃헙 원격저장소 만들기</b>
1. 회원가입 후 sign in 한다.
2. 초록색 new버튼 누르면 새 repository를 생성할 수 있다.(저장소 이름 입력 후 create repository)
_저장소 생성 후 보여지는 url로 로컬에서 원격저장소에 접근할 수 있다._

<b>원격저장소를 연결해서 로컬의 소스코드를 원격저장소에 업로드하기</b>
1. 로컬저장소(소스트리)의 메뉴에서 [repository]>[Add Remote]
2. 원격저장소의 정보(원격저장소 이름/URL)를 입력한다.
(입력 후 Remotes 항목에서 내가 추가해놓은 원격저장소를 확인 할 수 있다.)
3. 원격저장소와 로컬저장소를 동기화한다.
(push를 선택해서 push할 원격저장소 선택 > 브랜치체크)
4. GITHUB에 Commits항목에서 로컬에서의 Commit된 버전들을 확인한다.

<b>로컬에서 작업한파일 원격저장소로 업로드하기</b>
원격저장소와 동기화 한 후 로컬저장소에서 파일을 작업해 변경사항을 다시 Commit을 하면 push에 숫자'1'이 표시된다.
원격저장소와 로컬저장소 사이에 하나의 버전 차이가 존재한다는 뜻이며 버전리스트에도 원격저장소 브랜치 위치와 로컬저장소의 브랜치위치가 다른것을 확인할 수 있다.
Push를 눌러서 Commit한 버전을 업로드하면 된다.

#### 협업하기
_여러사람이 원격저장소에 접속할 수 있는 특성을 이용하여 공동으로 작업할 수 있는 기능_
<b>저장소 복제</b>
원격저장소에 있는 내용을 로컬저장소에 당겨오는 것(clone)
1. 북마크창에 New -> clone from URL(원격 저장소로부터 복제)
2. 원격저장소의 URL복사, Source URL에 붙여넣기
3. Destination Path에 폴더를 선택하고 clone
(북마크창에 새로운 repository가 생긴것을 확인할 수 있음)

<b>Push & Pull</b>
둘의 협업자가 서로 다른 부분을 수정했을 때 병합하기
우선 협업하는 사람은 버전관리시스템을 열고 작업 전 반드시 원격저장소에 새로운 버전이 올라간 것이 없는지 확인해야 된다.
이 때 사용하는것이 'pull'
(=작업 전 원격저장소와 로컬저장소를 같은 상태로 한 다음 작업해서 충돌을 예방한다.)
```
<협업자의 작업 순서>
(작업전) -> pull -> work -> commit -> pull -> push
```
<b>협업_충돌해결</b>
_작업자가 서로 같은 부분을 수정했을 때_
com1과 com2가 aa부분을 작업하고 com2가 먼저 push했을 때...
com1이 pull을 할 때 aa부분의 충돌이난다.
branch 충돌처럼 그 부분을 수정하고 commit 후 push하면 된다.
늘, 작업전 그리고 push전에 pull을 하면서 충돌을 최소화 해야한다.







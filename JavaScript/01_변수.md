# 변수란 무엇인가

변수(variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말하며 저장할 수 있는 값은 변할 수 있다.  

## 변수의 필요성

어떤 연산의 결과를 재사용하고 싶을 때 변수를 사용한다.

```javascript
var result = 10 + 20;
```

위와같이 `10 + 20`의 연산 결과를 `result`라는 이름의 변수에 할당했다.  
변수의 선언과 값이 할당되는 과정은 다음과 같다.

1. 메모리영역에 빈공간을 확보한다.
2. 확보한 공간의 이름을 `result`로 지정한다.
3. `10 + 20`을 계산한다.
4. `10 + 20`의 결과값인 30을 `result`라는 이름이 붙은 공간에 저장한다.

결과값을 재사용할 때는 또다시 `10 + 20`을 계산하는게 아닌 result변수를 사용하는 것이다.  
이렇게 어떠한 값을 재사용할 수 있도록 값이 저장된 메모리공간에 상징적인 이름을 붙인 것이 바로 **변수**다.

사실 좀 더 깊게 들어가면 흐름은 같지만 데이터 할당의 과정은 조금 다르다.  
변수 영역에 데이터를 직접 대입하지 않고 한단계를 더 거쳐서 별도의 메모리 공간을 다시 확보해서 결과값인 30을 저장하고, 그 주소를 `result`라는 이름이 붙여진 메모리공간에 저장하는 식으로 이뤄진다.([코어자바스크립트_데이터 타입 참고](https://velog.io/@ursr0706/%EC%BD%94%EC%96%B4-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-01Data-type))

내부의 동작을 다시 살펴보면 다음과 같다.  

1. 메모리영역에 빈공간을 확보한다.
2. 확보한 공간의 이름을 `result`로 지정한다.
3. `10 + 20`을 계산한다.
4. `10 + 20`의 결과값인 30을 별도로 확보된 메모리 공간에 저장한다.
5. `result`라는 이름이 붙여진 메모리 공간에 30이라는 데이터가 저장된 메모리영역의 주소를 저장한다.

위의 `result`와 같이 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 **변수 이름**이라하고 변수에 저장된 값을 **변수 값**이라고 한다.  

## 식별자

변수 이름을 식별자(identifier)라고도 한다. 어떤 데이터를 식별하는 데 사용하는 이름이라는 뜻이다.  
식별자는 메모리 주소를 기억하고 있는데 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근한다는 것을 의미한다.  
즉, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다.  
변수, 함수, 클래스 등의 이름과 같이 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름을 모두 식별자라고 한다.

## 변수 선언

**변수 선언**이란 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다.  
`var`키워드를 사용해서 변수를 선언할 수 있다.(ES6에서 `let`과 `const`키워드가 도입됐다)  
`var`키워드는 뒤에 오는 변수 이름으로 새로운 변수를 선언할 것을 지시하는 키워드이다.  

```javascript
var + 변수명+ ;
```

이렇게 하면 새로 변수가 생성되어 저장 공간을 예약해 두고 데이터를 저장할 준비를 한다.  
선언이후 변수에 값을 할당하지 않았을 때 확보된 메모리 공간에는 자바스크립트 엔진에 의해 `undefined`라는 값이 암묵적으로 할당되어 초기화된다.  
이는 자바스크립트의 독특한 특징으로 `var`키워드로 선언한 변수는 어떠한 값도 할당하지 않아도 undefined라는 값을 갖는다.

```javascript
var score;
console.log(score); //undefined 출력
```

## 변수 선언의 실행 시점과 변수 호이스팅

변수 선언문보다 변수를 참조하는 코드가 먼저 나온다면 참조 에러(ReferenceError)가 나타날까?  

```javascript
console.log(score); // ?
var score;
```

위와같이 score변수를 출력하는 명령문이 변수 선언문보다 앞에 있을 때 `console.log(score)`는 참조 에러를 발생시키지 않고 `undefined`가 출력된다.  
변수 선언은 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.  
자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기 앞서 코드를 쭉 훑으며 식별자의 정보를 순서대로 수집한다.  
코드가 순차적으로 실행되는 런타임 이전에 변수 선언을 먼저 실행된 것과 같다.
이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 호이스팅(hoisting)이라 한다.  

## 값의 할당

변수에 값을 할당할 때는 할당연산자 `=`를 사용한다.

```javascript
var score;
score = 80;
```

변수 선언과 값의 할당을 하나의 문으로 단축 표현할 수도 있다.

```javascript
var score = 80;
```

그러나 자바스크립트 엔진은 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다.  

```javascript
console.log(score); // undefined 출력

var score = 80;     // 변수 선언과 값의 할당

console.log(score); // 80 출력
```

위와같은 예시를 통해 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 변수 선언은 런타임 이전에 먼저 실행되고 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다는 것을 알 수 있다.
런타임 이전에 호이스팅현상으로 변수 선언이 먼저 실행되며 `undefined`가 할당되어 초기화되고, 코드가 한 줄씩 실행되며 `var score = 80;`의 코드가 실행될 때 score식별자는 더이상 `undefined`가 아닌 `80`이라는 데이터가 저장된 메모리주소를 저장하게 된다.  
(이전의 undefined가 저장되어 있던 메모리 공간에서 undefined를 지우고 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 곳에 80을 저장하는 점에 주의)  

## 식별자 네이밍 규칙

1. 식별자는 최소한 하나의 문자로 구성되어야 한다.
2. 식별자를 구성하는 첫 번째 글자는 반드시 하나의 문자나, _, $로 시작되어야 한다.
3. 숫자로 시작하는 것은 허용하지 않는다.
4. 예약어(프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어)는 식별자로 사용할 수 없다.
5. _와 $를 제외한 특수문자와 공백은 식별자를 구성할 수 없다.

또한 식별자는 보는이로 하여금 즉시 식별할 수 있도록 의미있는 이름으로 지어야 한다.  
좋은 이름은 코드의 가독성을 높인다.  

## 네이밍 컨벤션

하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙으로 네이밍 컨벤션을 잘 지키면 읽기 좋은 이름을 만들 수 있다.

```javascript
// 카멜 케이스 (camelCase)
var firstName;

// 스네이크 케이스 (snake_case)
var first_name;

// 파스칼 케이스 (PascalCase)
var FirstName;

// 헝가리언 케이스 (typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```

일반적인 방식은 변수나 함수의 이름에는 카멜 케이스를 사용하고 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용하는 것이다.

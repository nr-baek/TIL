# 객체 리터럴

## 객체란?

원시 자료형은 하나의 값을 저장한다.  
그러나 많은 정보를 처리해야 하는 경우가 많은데 몇십 개의 변수를 선언해서 값을 저장하면 코드가 점점 복잡해진다.  
여러 개의 값을 한번에 접근할 수 있도록, 자바스크립트는 객체(Object)를 제공한다.  
객체는 *값들을 그룹으로 묶은 데이터 모음*이며 이름(key)과 값(value)으로 구성된 **프로퍼티**들의 정렬되지 않은 집합이다.  

```javascript

var person = {
  name: 'Lee',  // 프로퍼티 키: 프로퍼티 값
  age: 20,  // 키:값의 쌍의 프로퍼티
  increase: function() {
    this.age++;           //  함수인 프로퍼티 값
  }
};
```

프로퍼티는 이름(Key)와 값(value)로 구성된다.  
프로퍼티 이름은 빈 문자열을 포함한 어떤 문자열이든 될 수 있으며 프로퍼티 값은 자바스크립트의 어떠한 값이든 될 수 있다.  
프로퍼티의 이름은 문자열이므로 따옴표로 묶어야하지만 따옴표를 생략 할 수도있다.  
그러나 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.  
이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓰며 에러가 발생하지않으니 주의해야 한다.
자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있으며 함수도 값이 될 수 있다. 프로퍼티 값이 함수일 경우 **메서드(method)** 라 부른다.

- 프로퍼티: 객체의 상태를 나타내는 값
- 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작

## 객체 생성하기

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

### 객체 리터럴에 의한 객체 생성

객체를 생성하는 가장 쉬운 방법은 객체 리터럴을 사용하는 것이다.  
객체 리터럴은 중괄호({..})안에, 이름과 값을 쌍점(:)으로 구분한 쌍을 쉼표로 연결한 리스트다.  
객체 리터럴에 프로퍼티를 포함시켜 객체 생성과 동시에 프로퍼티를 만들 수도 있고, 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있다.  

## 프로퍼티 접근

프로퍼티에 접근하는 두가지 방법

- 마침표 표기법
- 대괄호 표기법

마침표 또는 대괄호의 좌측에는 객체로 평가되는 표현식이 와야한다.  
마침표 표기법을 사용할 경우에는 마침표의 우측에 반드시 프로퍼티 이름이 식별자로 와야한다.  
대괄호 표기법을 사용할 경우, 대괄호([])안의 값은 반드시 프로퍼티 이름의 문자열로 평가되는 표현식이어야 한다.

```javascript
var person = {
  name = 'koko'
};

console.log(person.name);    // koko
console.log(person['name']); // koko
console.log(person.age);     // undefined
```

대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.  
따옴표로 감싸지 않은 이름을 프로퍼티 키로 사용하면 자바스크립트 엔진은 식별자로 해석한다.  
또한 객체에 존재하지 않는 프로퍼티에 접근하면 error가 발생하는 대신 undefined를 반환한다.  

## 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.  

```javascript
var person = {
  name = 'koko'
};

person.name = 'popo';

console.log(person);  //{name: "popo"}
```

## 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.  

```javascript
var person = {
  name = 'koko'
};

person.age = 28;

console.log(person); // {name: "koko", age: 28}
```

## 프로퍼티 삭제

delete연산자는 객체의 프로퍼티를 삭제한다.  
delete연산자는 하나의 피연산자를 갖는데, 이때 피연산자는 올바른 프로퍼티 접근 표현식이어야 한다.  
**(이 연산자는 프로퍼티 값을 지우는 것이 아니라 프로퍼티를 지운다.)**

```javascript
var person = {
  name = 'koko'
};

person.age = 28;

delete person["age"];

delete person.weight; // 존재하지 않는 프로퍼티를 삭제해도 에러가 발생하지 않음

console.log(person); // {name: "koko}
```

## ES6에서 추가된 객체 리터럴의 확장 기능

### 프로퍼티 축약 표현

프로퍼티 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.  
ES6에서는 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때, 프로퍼티 키를 생략할 수 있다.  
이때 프로퍼티 키는 변수 이름으로 자동 생성된다.

```javascript
let x =1, y = 2;

const obj = {x, y};

console.log(obj); // {x: 1, y: 2}
```

### 계산된 프로퍼티 이름

ES6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있다.  

```javascript
// ES6
const prefix = 'prop';
let i = 0;

// 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i
};

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

### 메서드 축약 표현

ES6에서는 메서드를 정의할 때, function 키워드를 생략한 축약 표현을 사용할 수 있다.

```javascript
// ES6
const obj = {
  name: 'Lee',
  // 메서드 축약 표현
  sayHi() {
    console.log('Hi! ' + this.name);
  }
};

obj.sayHi(); // Hi! Lee
```
